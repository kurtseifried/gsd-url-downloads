<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Reverse-engineering Broadcom wireless chipsets</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Fred Raynal">


    <!-- Le styles -->
    <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css" />
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }
      .tag-1 {
        font-size: 13pt;
      }
      .tag-2 {
        font-size: 10pt;
      }
      .tag-2 {
        font-size: 8pt;
      }
      .tag-4 {
        font-size: 6pt;
      }
    </style>
    <link href="./theme/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="./theme/css/font-awesome.css" rel="stylesheet">

    <link href="./theme/css/pygments.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
    <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="./theme/img/favicon.ico">
    <link rel="apple-touch-icon" href="./theme/img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="./theme/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="./theme/img/apple-touch-icon-114x114.png">

    <link href="./" type="application/atom+xml" rel="alternate" title="Quarkslab's blog ATOM Feed" />

  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="./index.html">Quarkslab's blog </a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="divider-vertical"></li>
                  <li >
                    <a href="./category/android.html">
                      <i class="icon-folder-open icon-large"></i>Android
                    </a>
                  </li>
                  <li >
                    <a href="./category/android-reverseengineering.html">
                      <i class="icon-folder-open icon-large"></i>Android, ReverseEngineering
                    </a>
                  </li>
                  <li >
                    <a href="./category/challenge.html">
                      <i class="icon-folder-open icon-large"></i>Challenge
                    </a>
                  </li>
                  <li >
                    <a href="./category/cryptography.html">
                      <i class="icon-folder-open icon-large"></i>Cryptography
                    </a>
                  </li>
                  <li >
                    <a href="./category/development.html">
                      <i class="icon-folder-open icon-large"></i>Development
                    </a>
                  </li>
                  <li >
                    <a href="./category/exploitation.html">
                      <i class="icon-folder-open icon-large"></i>Exploitation
                    </a>
                  </li>
                  <li >
                    <a href="./category/fuzzing.html">
                      <i class="icon-folder-open icon-large"></i>Fuzzing
                    </a>
                  </li>

              <ul class="nav pull-right">
                <li><a href="./archives.html"><i class="icon-th-list"></i>Archives</a></li>
              </ul>

            </ul>
            <!--<p class="navbar-text pull-right">Logged in as <a href="#">username</a></p>-->
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row">

        <div class="span3 well sidebar-nav" id="sidebar">
<style>
  .quarkslab__block {
      padding: 3px 22px; margin: 5px 0 5px;
  }
  .quarkslab__link {
      font-weight: bold; color:rgb(43, 47, 102);
      font-size: 16px
  }
  .quarkslab__link:hover{
      color: rgb(43 47 102 / 74%);
      text-decoration: none;
  }
</style>
<div class="quarkslab__block">
  <a class="quarkslab__link" href="https://quarkslab.com" target="_blank">Quarkslab&#39;s website</a>
</div><ul class="nav nav-list">
<li class="nav-header"><h4><i class="icon-home icon-large"></i> social</h4></li>
<li><a href="./feeds/all.rss.xml" rel="alternate"><i class="icon-bookmark icon-large"></i>atom feed</a></li>
    <li><a href="https://twitter.com/quarkslab"><i class="icon-twitter-sign icon-large"></i>twitter</a></li>
    <li><a href="https://github.com/quarkslab"><i class="icon-github-sign icon-large"></i>github</a></li>

<li class="nav-header"><h4><i class="icon-folder-close icon-large"></i>Categories</h4></li>
<li>
<a href="./category/android.html">
    <i class="icon-folder-open icon-large"></i>Android
</a>
</li>
<li>
<a href="./category/android-reverseengineering.html">
    <i class="icon-folder-open icon-large"></i>Android, ReverseEngineering
</a>
</li>
<li>
<a href="./category/challenge.html">
    <i class="icon-folder-open icon-large"></i>Challenge
</a>
</li>
<li>
<a href="./category/cryptography.html">
    <i class="icon-folder-open icon-large"></i>Cryptography
</a>
</li>
<li>
<a href="./category/development.html">
    <i class="icon-folder-open icon-large"></i>Development
</a>
</li>
<li>
<a href="./category/exploitation.html">
    <i class="icon-folder-open icon-large"></i>Exploitation
</a>
</li>
<li>
<a href="./category/fuzzing.html">
    <i class="icon-folder-open icon-large"></i>Fuzzing
</a>
</li>
<li>
<a href="./category/hardware.html">
    <i class="icon-folder-open icon-large"></i>Hardware
</a>
</li>
<li>
<a href="./category/hardware-reverseengineering.html">
    <i class="icon-folder-open icon-large"></i>Hardware, ReverseEngineering
</a>
</li>
<li>
<a href="./category/kernel-debugging.html">
    <i class="icon-folder-open icon-large"></i>Kernel Debugging
</a>
</li>
<li>
<a href="./category/life-at-quarkslab.html">
    <i class="icon-folder-open icon-large"></i>Life at Quarkslab
</a>
</li>
<li>
<a href="./category/maths.html">
    <i class="icon-folder-open icon-large"></i>Maths
</a>
</li>
<li>
<a href="./category/obfuscation.html">
    <i class="icon-folder-open icon-large"></i>Obfuscation
</a>
</li>
<li>
<a href="./category/pentest.html">
    <i class="icon-folder-open icon-large"></i>PenTest
</a>
</li>
<li>
<a href="./category/program-analysis.html">
    <i class="icon-folder-open icon-large"></i>Program Analysis
</a>
</li>
<li>
<a href="./category/programming.html">
    <i class="icon-folder-open icon-large"></i>Programming
</a>
</li>
<li>
<a href="./category/reverseengineering.html">
    <i class="icon-folder-open icon-large"></i>ReverseEngineering
</a>
</li>
<li>
<a href="./category/software.html">
    <i class="icon-folder-open icon-large"></i>Software
</a>
</li>
<li>
<a href="./category/vulnerability.html">
    <i class="icon-folder-open icon-large"></i>Vulnerability
</a>
</li>

<li class="nav-header"><h4><i class="icon-tags icon-large"></i>Tags</h4></li>


</ul>        </div><!--/.well -->

        <div class="span9">
<section id="content">
<article>
<header>
<h1>
  <a href=""
    rel="bookmark"
    title="Permalink to Reverse-engineering Broadcom wireless chipsets">
    Reverse-engineering Broadcom wireless chipsets
  </a>
</h1>
</header>
<div class="entry-content">
  <div class="well">
<footer class="post-info">
<span class="label">Date</span>
<abbr class="published" title="2019-04-16T00:00:00+02:00">
        <i class="icon-calendar"></i>Tue 16 April 2019
</abbr>
<span class="label">By</span>
<a href="./author/hugues-anguelkov.html"><i class="icon-user"></i>Hugues Anguelkov</a>
<span class="label">Category</span>
<a href="./category/reverseengineering.html"><i class="icon-folder-open"></i>ReverseEngineering</a>.


<span class="label">Tags</span>
	<a href="./tag/broadcom.html"><i class="icon-tag"></i>Broadcom</a>
	<a href="./tag/vulnerability.html"><i class="icon-tag"></i>vulnerability</a>
	<a href="./tag/cves.html"><i class="icon-tag"></i>CVEs</a>
	<a href="./tag/wifi.html"><i class="icon-tag"></i>WiFi</a>
	<a href="./tag/80211.html"><i class="icon-tag"></i>802.11</a>
	<a href="./tag/linux-drivers.html"><i class="icon-tag"></i>Linux drivers</a>
	<a href="./tag/reverse-engineering.html"><i class="icon-tag"></i>reverse engineering</a>
</footer><!-- /.post-info -->  </div>

  <div class="summary"><p class="first last">Broadcom is one of the major vendors of wireless devices worldwide. Since these chips are so widespread they constitute a high value target to attackers and any vulnerability found in them should be considered to pose high risk.  In this blog post I provide an account of my internship at Quarkslab which included obtaining, reversing and fuzzing the firmware, and finding a few new vulnerabilities.</p>
</div>

  <div class="section" id="introduction">
<h2>Introduction</h2>
<p>Broadcom is one of the major vendors of wireless devices worldwide. They sell
wireless chips labelled under the 43 series. You can find these chips
almost everywhere from smartphones to laptops, smart-TVs and IoT devices. You
probably use one without knowing it, for example if you have a Dell
laptop, you may be using a bcm43224 or a bcm4352 card. It is also likely you use a Broadcom WiFi chip if you
have an iPhone, a Mac book, a Samsumg phone or a Huawei phone, etc.</p>
<p>Since these chips are so widespread they constitute a high value target to attackers and any vulnerability found in them should be considered to pose high risk.</p>
<p>In 2018 I did a 6 months internship at Quarkslab with the purpose of reproducing and porting publicly known vulnerabilities to other vulnerable devices, to learn and improve several common infosec practices and to contribute to increase Quarkslab's knowledge of these devices. In this blog post I provide an account of my journey which included obtaining, reversing and fuzzing the firmware, and finding a few new vulnerabilities.</p>
<p>But first let's briefly speak about the 802.11 standard and its implementation on Linux to support the family of chips I studied.</p>
</div>
<div class="section" id="i-a-few-words-about-wlan-and-linux">
<h2>I. A few words about WLAN and Linux</h2>
<p>Before diving in let us have a look at the 802.11 wireless standard.</p>
<p>The first IEEE 802.11 standard <a class="footnote-reference" href="#id24" id="id1">[1]</a>, created in 1997, standardized the PHY and MAC layers, the two lowest OSI layers.</p>
<p>For the PHY layer, two frequency bands were chosen: the Infrared (IR)
band and Microwave band (2.4GHz). After that, other standards, like
the 802.11a <a class="footnote-reference" href="#id25" id="id2">[2]</a>, brought another frequency range (5GHz).</p>
<p>The MAC layer uses three types of frames: management, data and
control. The Frame Control field of the 802.11 header's frame
identifies the type on any given frame.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/iee80211_mac_frame_format.png" style="width: 800px;" />
<p>Management frames are managed by an entity called MLME (MAC subLayer
Management Entity). Depending on the location of the core that processes MLME we get two
major types of wireless chip implementations: SoftMAC, where the MLME is running in
the kernel driver, and HardMAC (also called FullMAC) where the MLME is in the
firmware, embedded in the chip. But life is not so simple and
some hybrid implementations also exist where, for example, probe responses and
requests are managed by the driver, but association requests and
authentication are dealt by the chip's firmware.</p>
<p>FullMAC devices offer better performance in terms of power consumption
and speed, that's why they are heavily used in smartphones and tend to
be the most used kind of chips in the market. Their main disadvantage is
that they limit ability of the users to send specific frames or to
set them in  monitor mode. For that one will need to edit directly the firmware
running on the chips.</p>
<p>From the Linux Operating System perspective the above gives us two major
layouts of components in the wireless stack: When the wireless device is a SoftMAC device, the
kernel will use a specific Linux Kernel Module (LKM) called 'mac80211'. This driver exposes
the MLME API in order to manage the Management frames, otherwise the kernel will use directly a hardware driver
and offload MLME processing to the chip's firmware.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/general_wifi_stack.png" style="width: 400px;" />
</div>
<div class="section" id="ii-introducing-broadcom-s-bcm43xxx-chips">
<h2>II. Introducing Broadcom's bcm43xxx chips</h2>
<p>The Broadcom bcm43xxx series have both HardMAC and SoftMAC cards. Unfortunately we could not find all the datasheets for all the chips we analyzed. The few datasheets available have been released by Cypress
after their acquisition of the &quot;IoT business&quot; branch of Broadcom.  It's worth mentioning that some chips integrate both WLAN and Bluetooth capabilities, like the bcm4339 or the bcm4330.</p>
<p>All the chips analysed use an ARM Cortex-M3 or an ARM
Cortex-R4 as the main MCU for non-time-critical operations, so we
deal with two similar instruction sets: armv7m and armv7r. These
MCUs have one ROM and one RAM, their size varies depending on the chipset's version.</p>
<p>All time-critical operations are realised by a Broadcom proprietary
processor called D11 core, mostly responsible of the PHY
layer.</p>
<p>Firmwares used by these chips are split in two parts: one part is
written into the ROM and cannot be modified, the other part is
uploaded by the driver into the chip's RAM. By doing so the vendor is
able to add new features or write updates for their chips, just by
changing the RAM portion of the firmware.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/blockdiagram.png" />
<p>FullMAC chips are very interesting, first as stated before the MLME
layer is implemented into the firmware code, but they also offer
offloading features like ARP cache, mDNS, EAPOL, etc. These chips
also have some hardware cryptographic modules allowing to encrypt and
decrypt the traffic, manage the keys, etc. All of the offloading features increase
the attack surface, giving us a nice playground.</p>
<p>In order to communicate with the Host (Application Processor), several
bus interfaces are used accross the b43 family: USB, SDIO and PCIe.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/tab.png" style="width: 850px;" />
<p>On the driver side, we can split the set of bcm43xxx drivers in two categories;
Open source and proprietary.</p>
<p>Open source:</p>
<ul class="simple">
<li>b43 (reversed from proprietary wl / old SoftMAC / Linux)</li>
<li>brcmsmac (SoftMAC / Linux)</li>
<li>brcmfmac (FullMAC / Linux)</li>
<li>bcmdhd ( FullMAC / Android)</li>
</ul>
<p>Proprietary:</p>
<ul class="simple">
<li>broadcom-sta aka 'wl' ( SoftMAC &amp;&amp; FullMAC / Linux)</li>
</ul>
<img alt="" class="align-left" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/bcm_global_stack.png" style="width: 850px;" />
<p>The 'wl' driver is the most used on embedded systems like routers. It is
also usually used on laptops that have a chip not supported by the
brcmfmac/brcmsmac driver, like the bcm4352 chip on the Dell XPS.
Also, the <cite>wl</cite> driver uses it's own MLME and doesn't need the LKM
'mac80211' to process Management frames, expanding the attack surface
for an attacker.</p>
<p>The version distributed by Broadcom is generally called an 'hybrid'
driver because the main part of the code comes in two compiled ELF -
objects used at compile time. Why two? because one is for the
x86_64 architecture and the other for i386. These objects hold the main code of
the driver and therefore expose a lot of Broadcom API's functions.</p>
<p>It is important to  mention that the chip's firmware and the <cite>wl</cite> driver share a lot of
code so vulnerabilities found in one may also be present in the other.</p>
</div>
<div class="section" id="iii-getting-the-firmware">
<h2>III. Getting the firmware</h2>
<div class="section" id="getting-the-first-part-ram-firmware-part">
<h3>1) Getting the first part: RAM firmware part</h3>
<p>As explained, the firmware is split in two parts. The easiest part
to grab is the RAM part, which is loaded into the RAM by the
driver. This part contains code and data used by the main MCU but also
the microcode used by the D11 core.</p>
<p>This part of the firmware is not signed, and integrity is 'verified' using a CRC32 checksum. This has lead to several firmware modifications in order to add functionalities like the monitor mode. For example,
SEEMO Lab has released the NEXMON project <a class="footnote-reference" href="#id26" id="id3">[3]</a>, which is an amazing
framework for modifying these firmwares by writing patches for them in C.</p>
<p>During our study we encountered two possible formats for the RAM
firmware image; the first and most commonly encountered was a
simple binary blob with no particular structure. The second was
the TRX format which could be easily parsed, when working on the
bcm43236 chip.</p>
<p>When working on the .bin RAM firmware we generally have a string at the
end of the file exposing:</p>
<ul class="simple">
<li>The chip's version</li>
<li>The bus used by the chip for the host to dongle communication</li>
<li>The features offered by the firmware; p2p, TDLS, etc.</li>
<li>The firmware's version</li>
<li>The CRC checksum</li>
<li>The date on which it was created.</li>
</ul>
<p>When the driver used is <cite>brmfmac</cite> or <cite>bcmdhd</cite> we can get the RAM firmware
directly from the host filesystem. On linux we can find it in
<cite>/lib/firmware/brcm</cite> or on Android in <cite>/system/vendor/firmware</cite>.
In other cases it will vary depending on the system we use.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/version_str.png" style="width: 850px;" />
<p>If the driver used is the proprietary <cite>wl</cite> we may find the
firmware's RAM part in the .data section of the LKM. It can be easily
extracted with LIEF <a class="footnote-reference" href="#id31" id="id4">[8]</a>.</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">lief</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">lief</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;wl.ko&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">wl</span><span class="o">.</span><span class="n">get_section</span><span class="p">(</span><span class="s2">&quot;.data&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">wl</span><span class="o">.</span><span class="n">symbols</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">if</span> <span class="s2">&quot;dlarray_&quot;</span> <span class="ow">in</span> <span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
<span class="o">...</span>             <span class="k">print</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">dlarray_4352pci</span>
<span class="n">dlarray_4350pci</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b4352</span> <span class="o">=</span> <span class="n">wl</span><span class="o">.</span><span class="n">get_symbol</span><span class="p">(</span><span class="s2">&quot;dlarray_4352pci&quot;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bcm4352_fw</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">content</span><span class="p">[</span><span class="n">b4352</span><span class="o">.</span><span class="n">value</span> <span class="p">:</span> <span class="n">b4352</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">b4352</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/tmp/bcm4352_ramfw.bin&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="o">...</span>     <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="n">bcm4352_fw</span><span class="p">))</span>
<span class="o">...</span>
<span class="mi">442233</span>
<span class="o">&gt;&gt;&gt;</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="gp">$</span> strings /tmp/bcm4352_ramfw.bin <span class="p">|</span> tail -n <span class="m">1</span>
<span class="go">4352pci-bmac/debug-ag-nodis-aoe-ndoe Version: 6.30.223.0 CRC: ff98ca92 Date: Sun 2013-12-15 19:30:36 PST FWID 01-9413fb21</span>
</pre></div>
<p>It is <cite>interesting</cite> to notice that the firmware released for the
bcm4352, used in the latest <cite>wl</cite> driver on Linux dates from 2013...</p>
</div>
<div class="section" id="recovering-the-second-part-introduction-to-the-rom-part">
<h3>2) Recovering the second part: introduction to the ROM part</h3>
<p>The ROM part of the firmware is the most important one to grab to
understand the internals of these chips.</p>
<p>In order to grab the ROM part, we need to know where it is mapped.
The best way to find the base address is to read the driver's header,
for example in the bcmdhd's headers file <cite>/include/hndsoc.h</cite>
<a class="footnote-reference" href="#id27" id="id5">[4]</a>. An alternate way is to read the Nexmon project README <a class="footnote-reference" href="#id26" id="id6">[3]</a>
which gives us other base addresses depending on the MCU models. The
astute reader may see that these addresses differ. The Nexmon project
specifies that the ROM for chips with a Cortex-M3 is loaded at
0x800000, and the bcmdhd's header says at 0x1e000000. Both are correct.  It
seems that the ROM and the RAM are mapped twice. Furthermore, knowing the
base address gives us a clue about the MCU used, for example if we dump the ROM at
0x000f0000, we know that the chip is using an ARM Cortex-R4.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/hdr_map.png" style="width: 700px;" />
</div>
<div class="section" id="getting-the-rom-part-on-an-android-system">
<h3>3) Getting the ROM part on an Android system</h3>
<p>On Android, we can use the <cite>dhdutil</cite> tool which is an Android
opensource improved fork of the old <cite>wlctl</cite> utility. By using the
'membytes' function of this tool we can dump the RAM of the chipsets,
and in some cases the ROM as well.</p>
<div class="highlight"><pre><span></span><span class="go">adb shell /data/local/tmp/dhdutil -i wlan0 membytes -r 0x0 0xa0000 &gt; rom.bin</span>
</pre></div>
<p>For example, on the bcm4339 chip used in the Nexus 5 which relies on a
Cortex-R4, the ROM is directly dumped. Unfortunately, on the older
bcm4330 (Cortex-M3) this doesnt work. But as long as you can interact with
the RAM, it is possible to hook a function with a little stub which
will copy the ROM, slice by slice, into an emtpy arena in the RAM. After
that we can dump all the ROM's slices.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/copy_stub.png" style="width: 200px;" />
</div>
<div class="section" id="recovering-the-rom-part-on-an-linux-system">
<h3>4) Recovering the ROM part on an Linux system</h3>
<p>On Linux with the brcmfmac driver, we cannot directly access the ROM. Therefore, we need to find
a way to interact with the chip's memory, directly  within the ROM or the RAM.
Luckily, when the chip uses a SDIO bus for communicating with the host the opensource <cite>brcmfmac</cite> driver
exposes the function <cite>brcmf_sdiod_ramrw</cite>. This function allows us to read and write into the chipset's RAM
from the host.</p>
<p>If we modify the driver in order to add an ioctl wrapper around this function, we may be able to read and write into the chipset's RAM from a tiny userspace utility.</p>
<p>Prior to calling <cite>brcmf_sdiod_ramrw</cite>, we must call <cite>sdio_claim_host</cite> in order to reclaim
the utilisation of the SDIO bus. Note that if the device is not connected to any
Access Point, the device may be in a low power-mode and the bus may
be idle, so we need to ensure that the device's bus is up by calling
<cite>bcmf_sdio_bus_sleep</cite> and <cite>brcmf_sdio_clkctl</cite>.</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">brcmf_ioctl_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">ndev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ifreq</span> <span class="o">*</span><span class="n">ifr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
             <span class="p">...</span>
             <span class="n">sdiobk</span><span class="o">-&gt;</span><span class="n">alp_only</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
             <span class="n">sdio_claim_host</span><span class="p">(</span><span class="n">sdiobk</span><span class="o">-&gt;</span><span class="n">sdiodev</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
             <span class="n">brcmf_sdio_bus_sleep</span><span class="p">(</span><span class="n">sdiobk</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
             <span class="n">brcmf_sdio_clkctl</span><span class="p">(</span><span class="n">sdiobk</span><span class="p">,</span> <span class="n">CLK_AVAIL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
             <span class="n">res</span> <span class="o">=</span> <span class="n">brcmf_sdiod_ramrw</span><span class="p">(</span><span class="n">sdiobk</span><span class="o">-&gt;</span><span class="n">sdiodev</span><span class="p">,</span> <span class="n">margs</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="n">margs</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">margs</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
             <span class="p">{</span>
                     <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;[!] Dumpmem failed for addr %08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">margs</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">);</span>
                     <span class="n">sdio_release_host</span><span class="p">(</span><span class="n">sdiobk</span><span class="o">-&gt;</span><span class="n">sdiodev</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                     <span class="n">kfree</span><span class="p">(</span><span class="n">buff</span><span class="p">);</span>
                     <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
             <span class="p">}</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">margs</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">margs</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                     <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEFAULT</span> <span class="s">&quot;[!] Can&#39;t copy buffer to userland.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
             <span class="p">...</span>
 <span class="p">}</span>
</pre></div>
<p>We need to write a small program to interact with our ioctl from the
userland. With it we should be able to read and write into the
device RAM:</p>
<div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">margs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">t_broadmem</span><span class="p">));</span>
<span class="n">margs</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="n">margs</span><span class="p">.</span><span class="n">op</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ERANGE</span><span class="p">)</span>
   <span class="n">prt_badarg</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">len</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ERANGE</span><span class="p">)</span>
   <span class="n">prt_badarg</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="n">margs</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">hex2byte</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ar</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">len</span><span class="p">);</span>
<span class="k">if</span> <span class="p">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">strncpy</span><span class="p">(</span><span class="n">ifr</span><span class="p">.</span><span class="n">ifr_name</span><span class="p">,</span> <span class="n">ar</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IFNAMSIZ</span><span class="p">);</span>
<span class="n">margs</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="n">ifr</span><span class="p">.</span><span class="n">ifr_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">margs</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SIOCDEVPRIVATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifr</span><span class="p">)))</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[+] Write succesfull!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">else</span>
   <span class="nf">printf</span><span class="p">(</span><span class="s">&quot;[!] Failed to write.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="k">return</span> <span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
<p>Now that we can read and write into the RAM of the chip, we can dump the ROM by:</p>
<ul class="simple">
<li>Hooking a function located in the RAM and called by an action X</li>
<li>Copying the ROM, slice by slice, into an empty area in the RAM (in our hook's stub)</li>
<li>Dumping all the freshly copied ROM slices and concatenating them.</li>
</ul>
<p>This protocol is the same as the one we used when the chip's MCU is a Cortex-M3 on Android. However, this time we had to modify the driver and build our own tools to use our new driver's ioctl.</p>
<p>We have chosen this method when working on the RPI3 chip's (bcm43430).</p>
</div>
<div class="section" id="getting-the-rom-part-in-specific-cases">
<h3>5) Getting the ROM part in specific cases</h3>
<p>There are still a lot of other possible scenarios:</p>
<p>. What if your chip is using the brcmfmac driver with an PCIe bus?
. What if your chip is on an embbedded system using the proprietary driver 'wl'?
. What if you don't have a shell on the host OS? Or if you lack permissions? And so on...</p>
<p>In all of these other cases, you are left with several possibilities: if you have
access to the hardware, you can look for UART access, or you may
hook the <cite>wl</cite> driver.
We have choosen the UART access when working on the 'SFR minidecoder TV' (bcm43236).</p>
<div class="highlight"><pre><span></span><span class="go">RTE (usbrdl) v5.90 (TOB) running on BCM43235 r3 @ 20/96/96 MHz.</span>
<span class="go">rdl0: Broadcom USB Remote Download Adapter</span>
<span class="go">ei 1, ebi 2, ebo 1</span>

<span class="go">RTE (USB-CDC) 6.37.14.105 (r) on BCM43235 r3 @ 20.0/96.0/96.0MHz</span>
<span class="go">000000.007 ei 1, ebi 2, ebo 1</span>
<span class="go">000000.054 wl0: Broadcom BCM43235 802.11 Wireless Controller 6.37.14.105 (r)</span>
<span class="go">000000.060 no disconnect</span>
<span class="go">000000.064 reclaim section 1: Returned 91828 bytes to the heap</span>
<span class="go">000001.048 bcm_rpc_buf_recv_mgn_low: Host Version: 0x6250e69</span>
<span class="go">000001.054 Connected Session:69!</span>
<span class="go">000001.057 revinfo</span>
<span class="go">000063.051 rpc uptime 1 minutes</span>

<span class="gp">&gt;</span> ?
<span class="go">000072.558 reboot</span>
<span class="go">000072.559 rmwk</span>
<span class="go">000072.561 dpcdump</span>
<span class="go">000072.563 wlhist</span>
<span class="go">000072.564 rpcdump</span>
<span class="go">000072.566 md</span>
<span class="go">000072.567 mw</span>
<span class="go">000072.569 mu</span>
<span class="go">000072.570 ?</span>
<span class="gp">&gt;</span>
</pre></div>
<p>The baudrate was 115200 b/s. The command <cite>md</cite> allows to dump memory at a specific address. You should specify the address and how much DWORD you want to dump. With a tiny PySerial script we have been able to dump the ROM and make live RAM snaphot.</p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">import</span> <span class="nn">serial</span>
<span class="kn">import</span> <span class="nn">binascii</span>

<span class="n">nb</span> <span class="o">=</span> <span class="mi">65535</span>
<span class="n">baseaddr</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">uart</span> <span class="o">=</span> <span class="n">serial</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span><span class="s1">&#39;/dev/ttyUSB0&#39;</span><span class="p">,</span> <span class="mi">115200</span><span class="p">)</span>
<span class="n">uart</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;md 0x</span><span class="si">%08x</span><span class="s1"> 4 </span><span class="si">%d</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">baseaddr</span><span class="p">,</span> <span class="n">nb</span><span class="p">))</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">dump</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">nb</span><span class="p">:</span>
    <span class="n">read</span> <span class="o">=</span> <span class="n">uart</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="sa">b</span><span class="s2">&quot;&gt;&quot;</span> <span class="ow">in</span> <span class="n">read</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">continue</span>
    <span class="k">if</span> <span class="sa">b</span><span class="s2">&quot;rpc&quot;</span> <span class="ow">in</span> <span class="n">read</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">continue</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Dump </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="se">\r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">read</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">read</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">dump</span> <span class="o">+=</span> <span class="n">binascii</span><span class="o">.</span><span class="n">unhexlify</span><span class="p">(</span><span class="n">read</span><span class="p">[</span><span class="mi">2</span><span class="p">][:</span><span class="o">-</span><span class="mi">2</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">uart</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/tmp/bcm43236_rom.bin&quot;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
   <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">dump</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="iv-reversing-the-firmware-the-journey-of-a-beacon">
<h2>IV. Reversing the firmware: the journey of a beacon</h2>
<p>In the last part, we used a lot the term 'RAM firmware', it must
not be mistaken with a 'RAM snaphot' which is a dump of the entire RAM
at runtime.</p>
<p>As stated by Gal.Beniamini <a class="footnote-reference" href="#id28" id="id7">[5]</a>, after firmware
initialisation some code inside the RAM will be reclaimed and used
for the internal heap of the chipset. If one wants to analyze those
firmwares, it is needed to analyse them with a genuine RAM
firmware and with a RAM snapshot.</p>
<div class="section" id="reversing-notes">
<h3>1) Reversing notes</h3>
<p>When everything is loaded in IDA, you will notice that nothing is recognised nor defined. We will need to select everything and force IDA to analyse it. Even if IDA recognizes and correctly defines much of the code and
data, there will still be a lot of strings and unrecognized code, or data interpreted as code. This is where IDApython comes in handy; using a tiny script, we were able to correctly define the code and the data.</p>
<p>When we feel that everything is correctly recognised by IDA, the fun part begins. Usually, if you have correctly set the base address, a lot of Xrefs should pop and several thousand functions should be detected. We don't have any symbols and all of the code is in thumb mode. The code itself looks very hard to understand.</p>
<p>One of the first things to do is to identify libc-like functions used, like <cite>memcpy</cite>, <cite>memove</cite>, etc. This can be done manually or using Sybil, a function divination tool <a class="footnote-reference" href="#id30" id="id8">[7]</a>.</p>
<p>The firmware relies on its own internal 'console' to print
information. This console is a simple buffer of 2048 bytes lying in
RAM. So the firmware gets its own home-brewed <cite>printf</cite> which is easily
recognised via the numerous format strings present. There
are other string formatting functions, like sprintf/snprintf, which are easily identified when the internal formating function is found and cross-referenced.</p>
<p>Functions related to the heap memory management (malloc and free) can be identified in different ways: we can find <cite>malloc</cite> via debug strings, or by looking for the classic pattern: <cite>x= malloc(y); memset(x, 0, y);</cite>
When <cite>malloc</cite> is found, we see that the allocator uses a single
linked list of free chunks. Cross referencing the pointer of the linked
list gives us the free function.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/malloc_freelist.png" style="width: 450px;" />
<p>The allocator is easy to understand: it is a best-fit allocator with
coalescing. The allocator is usually in RAM, so it can be updated and
change from device to device, or from one version to another.</p>
<p>The firmware uses a lot of structures, notably one called <cite>wlc_info</cite>, containing everything needed to control the chip.
Matthias SCHULTZ (SEEMO Lab) who is behind the NEXMON Project released
his thesis <a class="footnote-reference" href="#id29" id="id9">[6]</a> a few months ago. In his thesis he gave lots of
information about these different structures and linked the API's symbol names to the structure they take in arguments.</p>
<p>The firmware intialisation routine can be easily spotted by:</p>
<ul class="simple">
<li>Following the reset address call (generally found at 0x0).</li>
<li>Searching the function responsible of the CRC check. The CRC32 function can be easily found by searching one of the table value (e.g: 77073096). Then cross-referencing this function leads  to the firmware identity check.</li>
<li>Searching for the 'WFI' instruction and cross-referencing backward. After the initialisation, the chip just waits for any interrupt.</li>
</ul>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/fwloop.png" style="width: 850px;" />
</div>
<div class="section" id="packet-flow">
<h3>2) Packet flow</h3>
<p>Now, let us see how the frames are managed in a FullMAC device. When a
frame is received, an interrupt is triggered, the frame processing starts
in the FIQ interrupt handler.</p>
<p>Let's take a look at how frames are processed in the bcm4339 firmware. We start by
analyzing the Fast Interrupt handler (FIQ), we notice that this handler will grab a function pointer located on 0x181100 and pointing to a function at 0x181e48.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/fiqhandler.png" style="width: 600px;" />
<p>This function contains two branches: one used to catch bugs,
like bad memory accesses, the othe for the actual frame
processing.</p>
<p>If a memory violation occurs, the first branch will print a register
dump and a stack trace on the internal console (very convenient . It's
very useful when developing an exploit :)</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/intbranch.png" style="width: 750px;" />
<p>If we follow the second branch, we end up in a function at 0x0181A88
which will iterate through a linked list located at 0x00180E5C and
containing pointers to functions:</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/beforedpc.png" style="width: 600px;" />
<p>If we follow all the nested calls we end in the <cite>wlc_dpc</cite> functions.</p>
<p>This function retrieves a variable called <cite>macintstatus</cite> (as called in
an old version of brcmsmac) from the <cite>wlc_hw</cite> struct, and some checks are
performed.  The one we are interested in relies on the binary mask
defined in the macro <cite>MI_DMAINT</cite> (value 0x8000), if these bits are
set, we will jump into the function <cite>wlc_bmac_recv</cite>.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/wlcdpc.png" style="width: 500px;" />
<p>This function will remove a frame from a linked list (rx_fifo) located
in the shared memory of the MCU and the D11core, and construct a
custom sk_buff structure with it. Then the function <cite>wlc_recv</cite> is
called with two arguments: a pointer to the <cite>wlc</cite> structure and the
freshly initialised <cite>skb_buff</cite>.</p>
<p>This function can be considered the entry point of frame handling.</p>
<p>The <cite>skb_buff</cite> structure may depend on the device and version, but the
<cite>wlc_recv</cite> and <cite>wlc_bmac_recv</cite> can easily help to redefine it.</p>
<p>The <cite>wlc_recv</cite> function will strip the custom header added to the
frame by the d11core and retrieve the MAC header of the frame. A
check is done on the type subfield of the FC field in order to
correctly dispatch the frame to two handlers. One handler is for
Management and control frames (<cite>wlc_recv_mgmt_ctl</cite>), the other is for
Data frames (<cite>wlc_recvdata</cite>).</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/recv.png" style="width: 750px;" />
<p>If we want to know how beacon frames are processed, we just have to
look inside the <cite>wlc_recv_mgmt_ctl</cite> function, which will extract the
subtype from the FC field of the frame, then dispatch it to the
conrresponding handler.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/dispatch_bcn.png" style="width: 750px;" />
</div>
</div>
<div class="section" id="v-emulation-and-fuzzing">
<h2>V. Emulation and fuzzing</h2>
<p>Only one article mentions  emulation of these firmwares. It was
released by COMSECURIS <a class="footnote-reference" href="#id36" id="id10">[13]</a> along with their tools, a modified Qemu version
which is scriptable in Lua <a class="footnote-reference" href="#id37" id="id11">[14]</a>.</p>
<p>Since we did not want to emulate all the firmware we decided to follow our own path.</p>
<p>First, we tried to emulate some parts of the code (a simple call to
printf in whatever function) with the Unicorn framework.</p>
<p>We designed a tiny class wrapper around the Unicorn emulation engine,
allowing us to easily define all the emulation's parameter and load
them with jscon configuration file. These parameters include:</p>
<ul class="simple">
<li>the ROM file and its base address</li>
<li>the RAM snapshot file and its base address</li>
<li>start emulation address</li>
<li>stop emulation address</li>
<li>CPU context at the start</li>
</ul>
<p>We use our RAM snapshot and our previously gathered ROM. The RAM
snapshot contains everything needed, code and initialised structures.</p>
<p>We then decided to start fuzzing at the <cite>wlc_recv</cite> function.  For that we need
to put the <cite>wlc</cite> struct pointer in <cite>r0</cite>, and craft a <cite>skb_buff</cite>
structure with our frame data then put its pointer in <cite>r1</cite>.</p>
<p>To get a sample corpus, we have sniffed traffic sent to
our device in various situations then worked directly with the pcap
file. The fuzzing strategy was naive, as we only used random bitflips,
with a static seed for easy reproduction of the results.</p>
<p>In this scenario it is important to mention that the context in which the RAM snapshot
was made influences the fuzzing and the code's paths taken. For
example, if we want to fuzz a frame used during the association with an
AP, we need to dump the RAM when the chip is not connected to any AP.</p>
<p>So our procedure was the following; for each frame in our pcap file,
randomly flip some bits, write the fuzzed frame's data with crafted
d11 header in our RAM snaphot, then craft a <cite>skb_buff</cite> for our data
and also write it in the snapshot.</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
     <span class="nt">&quot;rom&quot;</span><span class="p">:</span>
     <span class="p">{</span>
             <span class="nt">&quot;addr&quot;</span><span class="p">:</span> <span class="s2">&quot;0x0&quot;</span><span class="p">,</span>
             <span class="nt">&quot;file&quot;</span><span class="p">:</span> <span class="s2">&quot;../../bcm4339/bcm4339_ROM.bin&quot;</span>
     <span class="p">},</span>
     <span class="nt">&quot;ram&quot;</span><span class="p">:</span>
     <span class="p">{</span>
             <span class="nt">&quot;addr&quot;</span><span class="p">:</span> <span class="s2">&quot;0x180000&quot;</span><span class="p">,</span>
             <span class="nt">&quot;file&quot;</span><span class="p">:</span> <span class="s2">&quot;../../tmp/unassoc_ram.bin&quot;</span>
     <span class="p">},</span>
     <span class="nt">&quot;cpu_context&quot;</span><span class="p">:</span>
     <span class="p">{</span>
             <span class="nt">&quot;sp&quot;</span><span class="p">:</span> <span class="s2">&quot;0x23d194&quot;</span><span class="p">,</span>
             <span class="nt">&quot;r0&quot;</span><span class="p">:</span> <span class="s2">&quot;0x001e8d8c&quot;</span><span class="p">,</span>
             <span class="nt">&quot;r1&quot;</span><span class="p">:</span> <span class="s2">&quot;0x23e6cf&quot;</span>
     <span class="p">},</span>
     <span class="nt">&quot;start_at&quot;</span> <span class="p">:</span> <span class="s2">&quot;0x1aafdc&quot;</span><span class="p">,</span>
     <span class="nt">&quot;stop_at&quot;</span> <span class="p">:</span> <span class="s2">&quot;0x1aafe0&quot;</span><span class="p">,</span>
     <span class="nt">&quot;console_ptr&quot;</span><span class="p">:</span> <span class="s2">&quot;0x1eb5d8&quot;</span><span class="p">,</span>
     <span class="nt">&quot;zone0&quot;</span> <span class="p">:</span>
     <span class="p">{</span>
             <span class="nt">&quot;addr&quot;</span><span class="p">:</span> <span class="s2">&quot;0x18000000&quot;</span><span class="p">,</span>
             <span class="nt">&quot;file&quot;</span><span class="p">:</span> <span class="s2">&quot;old/conf/mem1&quot;</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>We must ensure that:</p>
<ul class="simple">
<li>Our frames are correctly parsed and processed.</li>
<li>During fuzzing we do not get stuck in the same code path, again and again.</li>
</ul>
<p>To ensure we emulate the frame processing correctly, we have produced a trace by printing
each pc address and then verified that we correctly visited the corresponding frame handler.
In this way we can answer questiosn like: if we are fuzzing a beacon frame, are we
correctly reaching the <cite>wlc_recv_bcn</cite> function? and, How is our beacon being parsed?</p>
<p>In order to determine if are discovering new code paths with our
fuzzing, we have implemented a dirty new path's metric. First, we do a
blank emulation run without fuzzing the frame from our pcap file. During
this blank run, we record all the PC addresses and store them as keys
in a dictionary. When we start fuzzing, we keep recording all pc
addresses. If an address from the fuzzing run is not in our dictionary, we conclude we discovered
a new path.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/fuzz.png" />
<p>We also need to correctly detect bugs. Memory access violation are
spotted by Unicorn if we try to read or write outside a valid mapping,
but how can we detected heap overflows? COMSECURIS gives the solution:
hook the allocator functions.</p>
<p>In order to follow the different action realized, we have implemented a trace format like drcov. This allows us to replay and carefully analyze a fuzzing session in IDA Pro.</p>
</div>
<div class="section" id="vi-finding-vulnerabilities">
<h2>VI. Finding vulnerabilities</h2>
<p>Several vulnerabilities were discovered and publicly  disclosed in the past, like
CVE-2017-9417 discovered by Nitay Artenstein in <a class="footnote-reference" href="#id35" id="id12">[12]</a>. Gal Beniamini
also discovered several vulnerabilities in the chip's firmware and in the Linux's kernel driver.
Chaining these vulnerabilities allows remote compromise the host, as it was shown with an iPhone 7.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/vulnrecap.png" style="width: 600px;" />
<p>So far the majority of vulnerabilities discovered in the chip's firmware are due to misuse of the length value of Information Element.  An Information Element, <cite>IE</cite> for short, is a Tag Length Value (TLV) data structure used in
the IEEE 802.11b Management/Data frames. These IEs are used to carry
any information needed by either the supplicant or the access point. There are
two kinds of IEs: normal and vendor specific. Vendor specific IEs have a tag
with value 221 (0xdd) and the data field starts with four bytes: 3 bytes
containing the vendor OUI and one byte indicating the IE type.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/ietype.png" style="width: 600px;" />
<p>In the firmwares we analyzed the function dedicated to parsing of these IEs is named <cite>bcm_parse_tlvs</cite>. This function returns the following structure:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">bcm_tlv</span> <span class="p">{</span>
        <span class="kt">uint8_t</span> <span class="n">id</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">len</span><span class="p">;</span>
        <span class="kt">uint8_t</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">bcm_tlv_t</span><span class="p">;</span>
</pre></div>
<p>By cross-referencing it we find all the call sites where IEs are manipulated. Some of these functions are just a wrapper that looks for a vendor IE with a specific vendor OUI. Cross-referencing this wrapper leads us to yet more functions. There are more than one hundred call sites where these TLVs are manipulated.</p>
<p>By iterating thought all these Xref we found the previously discovered vulnerabilities such as CVE-2017-0561, a heap buffer overflow due to the direct use of the length value of an Fast Transition IE as the size parameter during an <cite>memcpy</cite> call <a class="footnote-reference" href="#id28" id="id13">[5]</a>.  It is worth noting that in the different firmwares we analyzed the function vulnerable to CVE-2017-0561 was located in ROM and so its code is unpatchable. In order to 'fix' the vulnerability the vendor had to deactivate the TDLS feature.</p>
<div class="section" id="cve-2019-9501-and-cve-2019-9502-two-heap-overflows-discovered">
<h3>CVE-2019-9501 and CVE-2019-9502: Two heap overflows discovered</h3>
<p>We continued iterating over the <cite>bcm_parse_tlvs</cite> call sites on the bcm4339 firmware and found one wrapper function at 0x14310 that searches for a vendor IE with an OUI of <cite>00:0F:AC</cite>, which is used in the 802.11i (Enhanced Security Mechanisms) protocol specification to select the Cipher suite, the Authentication and Key Management (AKM) suite, and the EAPOL-Key Key Data Encapsulation to use <a class="footnote-reference" href="#id38" id="id14">[15]</a>.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/wpafindkde.png" />
<p>Cross-referencing this function lead us to another wrapper at 0x14304 which we named <cite>wlc_find_gtk_encap</cite> that is only called from one function located at 0x7B45C, named <cite>wlc_wpa_sup_eapol</cite> after the formating strings referenced inside.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/wlcsupeapol.png" />
<p>Let's look at what this function does with the returned <cite>bcm_tlv</cite> structure:</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/eapol0.png" style="width: 450px;" />
<p>The function calls <cite>wlc_find_gtk_encap</cite> and checks if a pointer to a <cite>bcm_tlv</cite> structure is returned, if so it puts IE length value in register <cite>r2</cite> , address of IE data in <cite>r1</cite>, a pointer to a buffer structure in <cite>r0</cite> and calls <cite>memcpy()</cite> to copy the IE's data to the buffer pointed at by <cite>r0</cite>. Notice that there is no check that the size of the destination buffer is enough to hold  as many bytes as indicated by <cite>r2</cite>.</p>
<p>We have a potential buffer overflow in a structure but we don't yet know if the destination buffer is big enough to hold the copied data, let's keep following the execution flow. Next, the function <cite>wlc_wpa_plumb_gtk</cite> is called with the IE's length and the freshly copied buffer. The pseudocode of this function is:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span>     <span class="nf">wlc_wpa_plumb_gtk</span><span class="p">(...,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ie_data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len_ie</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
        <span class="p">...</span>
        <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
        <span class="p">...</span>

        <span class="n">buffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">164</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="p">...</span>
        <span class="p">}</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">164</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">ie_data</span><span class="p">,</span> <span class="n">len_ie</span><span class="p">);</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
<p>Here we have an obvious heap buffer overflow, the IE data are copied to a fixed-size buffer using a length controlled by an untrusted source (a potentially malicious AP). Gal Beniamini had already found other issues in the same <cite>wlc_wpa_plumb_gtk</cite> function: CVE-2017-11121 and CVE-2017-7065.</p>
<p>So far we have a heap buffer overflow, and potentially another one. We need to understand how to reach this code path and we need to check the size of the buffer used in the <cite>memcpy</cite> call right after the IE extraction. Upon further inspection of the  <cite>wl</cite> driver we find out that the buffer size is fixed at 32 bytes.</p>
<p>In summary, we found two buffer overflows: the first allow us to overflow at most 219 bytes, and the second 87 bytes, the next question we want to answer is &quot;How can we trigger these bugs ?&quot;</p>
<p>The WPA2 protocol use EAPOL (EAP On LAN), and a temporary key (GTK, which stands for Group Transient Key) to encrypt multicast traffic in the WLAN. This key is sent to a station during an EAPOL 4-way handshake, encapsulated in an vendor IE in EAPOL-Key Message 3.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/eapol.png" style="width: 300px;" />
<p>The <cite>wlc_wpa_sup_eapol</cite> function is responsible for parsing the Access Point messages during an EAPOL exchange. If we supply an GTK with a size of 255 in the EAPOL-M3 we will trigger these overflows.</p>
<p>To accomplish this easily we simply have to patch two lines of hostapd:</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/hostapd.png" style="width: 600px;" />
<p>As the firmware code and the <cite>wl</cite> proprietary driver share a lot of code, we found the same issues in the driver. This means that on systems using FullMAC devices an attacker controlling a malicious Access Point can compromise the chip, whereas on systems with SoftMAC devices an attack would lead to direct compromise of kernel memory.</p>
<p>To verify our findings we tried to connect a vulnerable SoftMAC bcm43263 chip, using the driver <cite>wl</cite>, to a rogue Access Point that delivered our PoC during the EAPOL exchange:</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/oops.png" style="width: 700px;" />
<p>These issues were present in all the firmwares analyzed, and in all versions of the <cite>wl</cite> driver analyzed. However, although  the code is present on all firmwares, it doesn't seem to be used on all versions. For example, it's not used on the firmware version of the bcm4339 that we analyzed but it's used on all firmware's version of the bcm43430 device.</p>
<p>In order to sucessfully exploit these bugs it is necessary to manipulate the heap layout remotely to obtain overlapping chunks. Gal Beniamini has already covered all aspects of heap exploitation of chip firmware <a class="footnote-reference" href="#id28" id="id15">[5]</a> <a class="footnote-reference" href="#id32" id="id16">[9]</a> <a class="footnote-reference" href="#id33" id="id17">[10]</a> <a class="footnote-reference" href="#id34" id="id18">[11]</a>.  Another researcher, Nitay Artenstein talked about this too <a class="footnote-reference" href="#id35" id="id19">[12]</a>, in his case the overflow was more easily exploitable because he was able to directly smash a pointer in the adjacent chunk which enabled a write-anything-anywhere primitive.</p>
<p>As stated above, one major problem on heap exploitation on these chips is the heap layout manipulation. There is almost no primitive that allows controlled size allocations with a controlled lifespan. We may find several controled size allocation primitive in several Management Action frame handlers but the allocated chunks are freed each time the primitive is used.
On the other hand, all the RAM on these chips is set with RWX permissions and there are no exploit mitigation mechanisms.</p>
</div>
<div class="section" id="vulnerabilities-in-the-linux-brcmfmac-driver">
<h3>Vulnerabilities in the Linux brcmfmac driver</h3>
<p>During the time researching the Broadcom firmware we also discovered two bugs in <cite>brcmfmac</cite>, the Linux kernel's open source wireless driver for FullMAC card.</p>
<p>As we said earlier, these chips use one of the three following BUS interface: USB, SDIO and PCIe. Built on the top of the bus, two mechanisms are use for the dongle to host and host to dongle communication.</p>
<p>The first communication method is mostly used for host to dongle communication and is based on custom ioctls. We may find in the firmware code the ioctl handler as an ugly big switch case.</p>
<img alt="" class="align-left" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/wl_ioctl.png" style="width: 850px;" />
<p>The second communication mechanism is called <cite>firmware events</cite>.
These firmware events are used by the chip to notify the host of differents events:
scanning results, association/disassociation, authentification, etc.
These events are encapsulated in regular TCP packets with an ethertype of 0x886c.</p>
<p>Gal Beniamini from Google Project Zero already found several issues related to these
firmware events in the Android Broadcom driver <cite>bcmdhd</cite> which allowed an attacker to
remotely compromise the host or to escalate from a compromised dongle to the kernels
host.</p>
</div>
<div class="section" id="cve-2019-9503-remotely-sending-firmware-events-bypassing-is-wlc-event-frame">
<h3>CVE-2019-9503: Remotely sending firmware events bypassing <cite>is_wlc_event_frame</cite></h3>
<p>Reading Gal.Beniamini articles <a class="footnote-reference" href="#id39" id="id20">[16]</a>, we learn that before April 2017, it was possible to remotely send crafted firmware events, using the chips like a proxy between the outside world and the kernel. Broadcom implemented a new mechanism to prevent frames coming from the exterior to be interpreted as firmware events. In order to do that, they introduced in the firmware a new function called <cite>is_wlc_events_frame</cite> which checks if a frame is a firmware event. In the <cite>bcmdhd</cite> driver used on Android, the same function is present since in order to be an effective solution the same check must be done in the firmware and the driver.</p>
<p>We have the following logic:</p>
<ul class="simple">
<li>On the firmware side, if a data frame received appear to be a firmware event it is directly discarded.</li>
<li>In the driver, if the frame is an event it is processed.</li>
</ul>
<p>Let's look how frames are managed on the open source linux driver <cite>brcmfmac</cite> and how firmware events are processed.
When the bus used is SDIO, there two different channels are set: one for event frames and one for all other frames.</p>
<p>In the file <cite>sdio.c</cite>, at the function <cite>brcmf_sdio_readframes</cite>:</p>
<div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">if</span> <span class="p">(</span><span class="n">brcmf_sdio_fromevntchan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dptr</span><span class="p">[</span><span class="n">SDPCM_HWHDR_LEN</span><span class="p">]))</span>
        <span class="n">brcmf_rx_event</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">sdiodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pfirst</span><span class="p">);</span>
<span class="k">else</span>
        <span class="nf">brcmf_rx_frame</span><span class="p">(</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">sdiodev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">pfirst</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
<p>We clearly see that if the frame comes from the event channel then a dedicated function is used <cite>brcmf_rx_event</cite>, else the function <cite>brcmf_rx_frame</cite> is called.</p>
<p>The function <cite>brcmf_rx_frame</cite> is prototyped as follow in <cite>bus.h</cite>:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">brcmf_rx_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">rxp</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">handle_event</span><span class="p">);</span>
</pre></div>
<p>The last arguments is a boolean used to indicate whether or not frames that contain a firmware event are processed. So we've checked the driver's code to see if this function was called with a <cite>handle_event</cite> parameter with a <cite>true</cite> value.</p>
<p>When a USB bus is used there is not a dedicated channel to receive events and all frames are processed, even firmware events.</p>
<p>In <cite>usb.c</cite> at function <cite>brcmf_usb_rx_complete</cite>:</p>
<div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">if</span> <span class="p">(</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">bus_pub</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">BRCMFMAC_USB_STATE_UP</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">skb_put</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">actual_length</span><span class="p">);</span>
        <span class="n">brcmf_rx_frame</span><span class="p">(</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="n">brcmf_usb_rx_refill</span><span class="p">(</span><span class="n">devinfo</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">brcmu_pkt_buf_free_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">brcmf_usb_enq</span><span class="p">(</span><span class="n">devinfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devinfo</span><span class="o">-&gt;</span><span class="n">rx_freeq</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
<p>So, if the bus is USB and if we find a way to bypass the <em>firmware</em> function <cite>is_wlc_event</cite> frame, we may me able to remotely send firmware event to the driver.</p>
<p>Let's take a look at how firmware events are processed from the function <cite>brcmf_rx_frame</cite>:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">brcmf_rx_frame</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">handle_event</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">brcmf_if</span> <span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">brcmf_bus</span> <span class="o">*</span><span class="n">bus_if</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
        <span class="k">struct</span> <span class="n">brcmf_pub</span> <span class="o">*</span><span class="n">drvr</span> <span class="o">=</span> <span class="n">bus_if</span><span class="o">-&gt;</span><span class="n">drvr</span><span class="p">;</span>

        <span class="n">brcmf_dbg</span><span class="p">(</span><span class="n">DATA</span><span class="p">,</span> <span class="s">&quot;Enter: %s: rxp=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">skb</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">brcmf_rx_hdrpull</span><span class="p">(</span><span class="n">drvr</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">brcmf_proto_is_reorder_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">brcmf_proto_rxreorder</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="cm">/* Process special event packets */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">handle_event</span><span class="p">)</span>
                        <span class="n">brcmf_fweh_process_skb</span><span class="p">(</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">drvr</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

                <span class="n">brcmf_netif_rx</span><span class="p">(</span><span class="n">ifp</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
      <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>If <cite>handle_event</cite> is set to <cite>true</cite>, the <cite>skb</cite> (socket buffer) is passed to the function <cite>brcmf_fweh_process_skb</cite>.
This function is defined in <cite>fweh.h</cite>:</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">brcmf_fweh_process_skb</span><span class="p">(</span><span class="k">struct</span> <span class="n">brcmf_pub</span> <span class="o">*</span><span class="n">drvr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">brcmf_event</span> <span class="o">*</span><span class="n">event_packet</span><span class="p">;</span>
        <span class="n">u16</span> <span class="n">usr_stype</span><span class="p">;</span>

        <span class="cm">/* only process events when protocol matches */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">ETH_P_LINK_CTL</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">event_packet</span><span class="p">))</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="cm">/* check for BRCM oui match */</span>
        <span class="n">event_packet</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">brcmf_event</span> <span class="o">*</span><span class="p">)</span><span class="n">skb_mac_header</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">BRCM_OUI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">oui</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">event_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">oui</span><span class="p">)))</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="cm">/* final match on usr_subtype */</span>
        <span class="n">usr_stype</span> <span class="o">=</span> <span class="n">get_unaligned_be16</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event_packet</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">usr_subtype</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">usr_stype</span> <span class="o">!=</span> <span class="n">BCMILCP_BCM_SUBTYPE_EVENT</span><span class="p">)</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="n">brcmf_fweh_process_event</span><span class="p">(</span><span class="n">drvr</span><span class="p">,</span> <span class="n">event_packet</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">ETH_HLEN</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>This function is responsible of validation of event frames. The function checks if the protocol is 0x886c, then checks if the size is sufficient for containing a structure <cite>brcmf_event</cite>. This structure is defined as follow:</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * struct brcm_ethhdr - broadcom specific ether header.</span>
<span class="cm"> *</span>
<span class="cm"> * @subtype: subtype for this packet.</span>
<span class="cm"> * @length: TODO: length of appended data.</span>
<span class="cm"> * @version: version indication.</span>
<span class="cm"> * @oui: OUI of this packet.</span>
<span class="cm"> * @usr_subtype: subtype for this OUI.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">brcm_ethhdr</span> <span class="p">{</span>
        <span class="n">__be16</span> <span class="n">subtype</span><span class="p">;</span>
        <span class="n">__be16</span> <span class="n">length</span><span class="p">;</span>
        <span class="n">u8</span> <span class="n">version</span><span class="p">;</span>
        <span class="n">u8</span> <span class="n">oui</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
        <span class="n">__be16</span> <span class="n">usr_subtype</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">brcmf_event_msg_be</span> <span class="p">{</span>
        <span class="n">__be16</span> <span class="n">version</span><span class="p">;</span>
        <span class="n">__be16</span> <span class="n">flags</span><span class="p">;</span>
        <span class="n">__be32</span> <span class="n">event_type</span><span class="p">;</span>
        <span class="n">__be32</span> <span class="n">status</span><span class="p">;</span>
        <span class="n">__be32</span> <span class="n">reason</span><span class="p">;</span>
        <span class="n">__be32</span> <span class="n">auth_type</span><span class="p">;</span>
        <span class="n">__be32</span> <span class="n">datalen</span><span class="p">;</span>
        <span class="n">u8</span> <span class="n">addr</span><span class="p">[</span><span class="n">ETH_ALEN</span><span class="p">];</span>
        <span class="kt">char</span> <span class="n">ifname</span><span class="p">[</span><span class="n">IFNAMSIZ</span><span class="p">];</span>
        <span class="n">u8</span> <span class="n">ifidx</span><span class="p">;</span>
        <span class="n">u8</span> <span class="n">bsscfgidx</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * struct brcmf_event - contents of broadcom event packet.</span>
<span class="cm"> *</span>
<span class="cm"> * @eth: standard ether header.</span>
<span class="cm"> * @hdr: broadcom specific ether header.</span>
<span class="cm"> * @msg: common part of the actual event message.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">brcmf_event</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">ethhdr</span> <span class="n">eth</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">brcm_ethhdr</span> <span class="n">hdr</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">brcmf_event_msg_be</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__packed</span><span class="p">;</span>
</pre></div>
<p>Finally, the OUI and the <cite>usr_subtype</cite> are checked. If our frame is a <cite>correctly</cite> formatted firmware event, it will be sent to the function <cite>brcmf_fweh_process_event</cite> which will queue the event for processing.</p>
<p>Now, let's look at how the function <cite>is_wlc_event_frame</cite> works inside the chip's firmware. We can also look at its definition in the <cite>bcmdhd</cite> source code, as normally the function used by the driver and the chipset need to be identic, otherwise the validation of the frame event could be bypassed.
To find the location of <cite>is_wlc_event_frame</cite> inside the chip's firmware and where it is called, we have several options: follow the execution flow of frame data processing or simply search for code locations where the value 0x886c is used.</p>
<img alt="" class="align-center" src="resources/2019-04-16_reversing-broadcom-wifi-chipsets/checkether.png" style="width: 600px;" />
<p>If <cite>is_wlc_event_frame</cite> returns a result different of -30, the frame is discarded.</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">is_wlc_event_frame</span><span class="p">(</span><span class="n">bcm_event</span> <span class="o">*</span><span class="n">pktdata</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pktlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exp_usr_subtype</span><span class="p">,</span> <span class="kt">signed</span> <span class="kt">int</span> <span class="n">a4</span><span class="p">)</span>
<span class="p">{</span>
        <span class="p">...</span>

  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">bcmeth_hdr_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pktdata</span> <span class="o">+</span> <span class="n">pktlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pktdata</span><span class="o">-&gt;</span><span class="n">bcm_hdr</span> <span class="o">&amp;&amp;</span> <span class="n">SLOBYTE</span><span class="p">(</span><span class="n">pktdata</span><span class="o">-&gt;</span><span class="n">bcm_hdr</span><span class="p">.</span><span class="n">subtype</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="k">return</span> <span class="o">-</span><span class="mi">30</span><span class="p">;</span>

<span class="p">...</span>
</pre></div>
<p>If the lowbyte of the field <cite>bcm_hdr.subtype</cite> is greater or equal to 0 then the function will return -30.
The field subtype isn't checked in <cite>brcmf_fweh_processed_skb</cite>, so by supplying a subtype &gt;= 0, we will pass the firmware check, the frame will be passed to the driver and then processed as valid in a firmware handler. When the bus used is PCIe, Broadcom implemented their own protocol called <cite>MSGBUF</cite> which doesn't use a particular channel for firmware event reception like SDIO.</p>
<p>This vulnerability can be used to remotely send firmware events to the host on chips using an USB or PCIe bus, bypassing the firmware's internal check done in <cite>is_wlc_event_frame</cite>.</p>
</div>
<div class="section" id="cve-2019-9500-heap-buffer-overflow-in-brcmf-wowl-nd-results">
<h3>CVE-2019-9500: Heap buffer overflow in <cite>brcmf_wowl_nd_results</cite></h3>
<p>Now that we're able to remotely send firmware events let's look into how they are processed and dispatched.</p>
<p>Firmware event processing starts in the function <cite>brcmf_fweh_event_worker</cite>, which will call the function <cite>brcmf_fweh_call_event_handler</cite>.</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">brcmf_fweh_call_event_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">brcmf_if</span> <span class="o">*</span><span class="n">ifp</span><span class="p">,</span>
                                        <span class="k">enum</span> <span class="n">brcmf_fweh_event_code</span> <span class="n">code</span><span class="p">,</span>
                                        <span class="k">struct</span> <span class="n">brcmf_event_msg</span> <span class="o">*</span><span class="n">emsg</span><span class="p">,</span>
                                        <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">brcmf_fweh_info</span> <span class="o">*</span><span class="n">fweh</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ifp</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fweh</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ifp</span><span class="o">-&gt;</span><span class="n">drvr</span><span class="o">-&gt;</span><span class="n">fweh</span><span class="p">;</span>

                <span class="cm">/* handle the event if valid interface and handler */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fweh</span><span class="o">-&gt;</span><span class="n">evt_handler</span><span class="p">[</span><span class="n">code</span><span class="p">])</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="n">fweh</span><span class="o">-&gt;</span><span class="n">evt_handler</span><span class="p">[</span><span class="n">code</span><span class="p">](</span><span class="n">ifp</span><span class="p">,</span> <span class="n">emsg</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
                <span class="k">else</span>
                        <span class="n">brcmf_err</span><span class="p">(</span><span class="s">&quot;unhandled event %d ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">brcmf_err</span><span class="p">(</span><span class="s">&quot;no interface object</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>The <cite>evt_handler</cite> is an array of function pointers. This array is populated by calling the function <cite>brcmf_fweh_register</cite>:</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * brcmf_fweh_register() - register handler for given event code.</span>
<span class="cm">*</span>
<span class="cm"> * @drvr: driver information object.</span>
<span class="cm"> * @code: event code.</span>
<span class="cm"> * @handler: handler for the given event code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">brcmf_fweh_register</span><span class="p">(</span><span class="k">struct</span> <span class="n">brcmf_pub</span> <span class="o">*</span><span class="n">drvr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">brcmf_fweh_event_code</span> <span class="n">code</span><span class="p">,</span>
        <span class="n">brcmf_fweh_handler_t</span> <span class="n">handler</span><span class="p">)</span>
</pre></div>
<p>By searching where this function is called we find all event handler functions. When the WOWL (Wake Up On WirelessLAN) feature is activated the handler of the event of type  <cite>BRCMF_E_PFN_NET_FOUND</cite> is unregistered and another handler is registered.</p>
<p>This handler is the function <cite>brcmf_wowl_nd_results</cite> shown below:</p>
<div class="highlight"><pre><span></span><span class="n">brcmf_wowl_nd_results</span><span class="p">(</span><span class="k">struct</span> <span class="n">brcmf_if</span> <span class="o">*</span><span class="n">ifp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">brcmf_event_msg</span> <span class="o">*</span><span class="n">e</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">brcmf_cfg80211_info</span> <span class="o">*</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">ifp</span><span class="o">-&gt;</span><span class="n">drvr</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">brcmf_pno_scanresults_le</span> <span class="o">*</span><span class="n">pfn_result</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">brcmf_pno_net_info_le</span> <span class="o">*</span><span class="n">netinfo</span><span class="p">;</span>

        <span class="n">brcmf_dbg</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span> <span class="s">&quot;Enter</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">datalen</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pfn_result</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">netinfo</span><span class="p">)))</span> <span class="p">{</span>
                <span class="n">brcmf_dbg</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span> <span class="s">&quot;Event data to small. Ignore</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pfn_result</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">brcmf_pno_scanresults_le</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">event_code</span> <span class="o">==</span> <span class="n">BRCMF_E_PFN_NET_LOST</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">brcmf_dbg</span><span class="p">(</span><span class="n">SCAN</span><span class="p">,</span> <span class="s">&quot;PFN NET LOST event. Ignore</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pfn_result</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">brcmf_err</span><span class="p">(</span><span class="s">&quot;Invalid result count, expected 1 (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                        <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pfn_result</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">));</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">data</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">brcmf_pno_scanresults_le</span><span class="p">);</span>
        <span class="n">netinfo</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">brcmf_pno_net_info_le</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">.</span><span class="n">ssid</span><span class="p">,</span> <span class="n">netinfo</span><span class="o">-&gt;</span><span class="n">SSID</span><span class="p">,</span> <span class="n">netinfo</span><span class="o">-&gt;</span><span class="n">SSID_len</span><span class="p">);</span> <span class="c1">//OVERFLOW YAY!</span>
        <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">ssid</span><span class="p">.</span><span class="n">ssid_len</span> <span class="o">=</span> <span class="n">netinfo</span><span class="o">-&gt;</span><span class="n">SSID_len</span><span class="p">;</span>
        <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">n_channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
                <span class="n">ieee80211_channel_to_frequency</span><span class="p">(</span><span class="n">netinfo</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
                <span class="n">netinfo</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">&lt;=</span> <span class="n">CH_MAX_2G_CHANNEL</span> <span class="o">?</span>
                <span class="nl">NL80211_BAND_2GHZ</span> <span class="p">:</span> <span class="n">NL80211_BAND_5GHZ</span><span class="p">);</span>
        <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd_info</span><span class="o">-&gt;</span><span class="n">n_matches</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd_info</span><span class="o">-&gt;</span><span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd</span><span class="p">;</span>

        <span class="cm">/* Inform (the resume task) that the net detect information was recvd */</span>
        <span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd_data_completed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfg</span><span class="o">-&gt;</span><span class="n">wowl</span><span class="p">.</span><span class="n">nd_data_wait</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>When <cite>memcpy</cite> is called in order to copy the SSID, the length used is the one provided in the event's frame data and is not checked. The 802.11 standard specifies that an eSSID will never exceed 32 bytes but an attacker may remotely send a firmware event with a <cite>ssid size</cite> greater than 32 bytes, triggering an heap buffer-overflow. This issue has been silently patched (cf: disclosure timelime).</p>
<p>A similar issue was found in the <cite>brcmf_notify_sched_scan_results</cite>, the handler for the same event (<cite>BRCMF_E_PFN_NET_FOUND</cite>) when WOWL is deactivated. The issue was silently patched by Broadcom in April 2017 <a class="footnote-reference" href="#id40" id="id21">[17]</a>, but the handler used when WoWL was enabled was forgotten. As we were working on an outdated <cite>brcmfmac</cite> version at the time we found these issue, a PoC triggering the overflow in <cite>brcmf_notify_sched_scan_results</cite> and panicking the kernel was accomplished by modifying airbase-ng <a class="footnote-reference" href="#id41" id="id22">[18]</a>, a tool from the aircrack-ng suite. An exploit or just a PoC can also be made using scapy <a class="footnote-reference" href="#id42" id="id23">[19]</a> or modifying <cite>wpa_supplicant</cite> or <cite>hostapd</cite>.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>In this blogpost I provided an account of various activities during my 6 months as an intern at Quarkslab, my project involved understanding the Linux kernel drivers, analyzing Broadcom firmware, reproducing publicly known vulnerabilities, working on an emulator to run portions of firmware, fuzzing and finding 5 vulnerabilities (CVE-2019-8564, CVE-2019-9500, CVE-2019-9501, CVE-2019-9502, CVE-2019-9503). Two of those vulnerabilities are present both in the Linux kernel and firmware of affected Broadcom chips. The most common exploitation scenario leads to a remote denial of service. Although it is technically challenging to achieve, exploitation for remote code execution should not be discarded as the worst case scenario.</p>
<p>At the time of publication of this blog post we do not have an exhaustive list of affected devices, nor do we know where can they be found.</p>
<div class="section" id="disclosure-timeline">
<h3>Disclosure timeline</h3>
<ul class="simple">
<li>2018-09-13: Email sent to Broadcom detailing the vulnerabilities</li>
<li>2018-09-13: Reply from Broadcom acknowledging the report.</li>
<li>2018-09-19: Broadcom asks if Quarkslab has a communication plan for the bugs.</li>
<li>2018-09-20: Quarkslab replies it plans to publish a blog post and provides URLs to prior publications as example. Asks if Broadcom could reproduce the bugs and if they were already known to them.</li>
<li>2018-09-20: Broadcom replies that they have &quot;limited ability to share our plans and findings&quot; because there isn't a Non-Disclosure Agreement (NDA) signed between the companies and they would be sharing non-public information.</li>
<li>2018-09-20: Quarkslab replies that it is not possible to coordinate disclosure if one of the involved parties -the reporter- has no information about whether the bugs are confirmed and if and when the vendor plans to issue fixes, and that it cannot agree to sign an NDA that would prevent reporting to customers and the general public and provide transparency about how the disclosure process was handled. Finally, Quarkslab asks if there is any information that Broadcom may provide that would not require signing an NDA.</li>
<li>2018-09-20: Broadcom asks if there is a date set for the publication.</li>
<li>2018-09-20: Reply indicating the date is not set and it is not entirely dependent on Quarkslab.</li>
<li>2018-10-28: Email set to CERT/CC asking for help to coordinate with Broadcom (since it is a US-based vendor) given their response to the vulnerability report. A write up with technical details about the bugs and a brief timeline of previous communications is provided.</li>
<li>2018-10-30: CERT/CC reply asking for further details such as list of vulnerable devices, proof-of-concept program and the planned date of publication.</li>
<li>2018-10-30: Quarkslab replies pointing to page 2 of the report which lists versions of firmware confirmed vulnerable. Indicates that PoC is not available at the moment but may be sent the following week and that the publication date is not set, and that both things may not be easy to do since they also depend on availability of a former intern.</li>
<li>2018-11-01: Email from Apple saying that Broadcom shared Quarkslab's report with them, they are investigating one of the vulnerabilities and would like to coordinate disclosure. Asks if disclosure date has been set.</li>
<li>2018-11-06: Reply from Quarkslab informing Apple that CERT/CC is on the loop as well, explains that Broadcom said it will not provide information unless an NDA is signed, and that the publication date is not set but would likely be before the end of the year. Quarkslabs asks if a CVE ID has been assigned.</li>
<li>2018-11-13: Apple replies that a CVE ID will be assigned closer to patch release date and that they will reach out for credit information.</li>
<li>2019-01-09: Email from CERT/CC requesting a status update</li>
<li>2019-01-10: Reply saying that Quarkslab has not received any communication from Broadcom since 2018-09-20 and the last contact with Apple was on 2018-11-13. Quarkslabs asks if CERT/CC has any news.</li>
<li>2019-03-08: Email to CERT/CC asking if there are any news.</li>
<li>2019-03-26: CERT/CC replies that it received a response from Broadcom that did not confirm nor deny the bug report. Apple replied its working on a fix that will be released on April 14th, 2019. CERT/CC asks Quarkslab if there is any new information.</li>
<li>2019-03-28: Apple informs they will be releasing a patch on April 14th, 2019 and asks if Quarkslab would like the bug discoverer to be credited.</li>
<li>2019-04-08: Quarkslab sends mail to Apple and CERT/CC asking if the fix will be for one or more vulnerabilities. Points out that Broadcom <a class="reference external" href="https://github.com/torvalds/linux/commit/1b5e2423164b3670e8bc9174e4762d297990deff#diff-66ea469ce534d8c3ba7147099b87fe78">committed a fix</a> to a bug in their open source Linux kernel driver on February 14th, 2019 without a CVE ID nor a security notice, and asks if Apple will be fixing the same bug.</li>
<li>2019-04-08: CERT/CC asks for permission to send a general notification that includes the report originally sent by Quarkslab in September 2018, says it will assign CVE IDs and that it is drafting a security note that will send for comments.</li>
<li>2019-04-08: Quarkslab agrees to have the vulnerability report disseminated.</li>
<li>2019-04-10: CERT/CC sends draft vulnerability note and asks if any of the heap overflows could result in code execution. Also asks for URL to Quarkslab blog post.</li>
<li>2019-04-11: Apple sends CVE ID and draft of paragraph describing their bugfix. States they are fixing a bug different than the one Broadcom patched in the <cite>brcmfmac</cite> Linux kernel driver</li>
<li>2019-04-12: Quarkslab replies that the GTK bugs could result in remote code execution either on the Linux kernel or on the chipset, depending on the type of device used (SoftMAC or FullMAC). Remote heap layout manipulation is very complicated but RCE should not be discarded as worst case scenario. In the most likely case exploitation will result in a remote DoS. Quarkslab will provide publication URL on the week of April 14th.</li>
<li>2019-04-12: Apple asks for draft of our blog post. Quarkslab replies that is not yet ready.</li>
<li>2019-04-12: CERT/CC sends update vulnerability note with summary description of each vuln and assigned CVE IDs. Points out that on February 14th, 2019 Broadcom had also <a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a4176ec356c73a46c07c181c6d04039fafa34a9f">fixed another bug</a> that was described in the report Quarkslab sent in September 2018. The original response from the vendor indicated that they did not support the <cite>brcmfmac driver</cite> (even though they apparently later supplied patches), and they would not provide information about the <cite>wl</cite> driver.</li>
<li>2019-04-15: CERT/CC asks if Quarkslab will publish on this date. Corrects one of the CVE IDs previously provided.</li>
<li>2019-04-15: Quarkslab replies that blog post will very likely go live on the 16th.</li>
<li>2019-04-15: Apple sends link to <a class="reference external" href="https://support.apple.com/en-us/HT209600">Security Update 2019-002</a> that fixes CVE-2019-8564</li>
<li>2019-04-16: This blog post is published.</li>
</ul>
</div>
<div class="section" id="acknowledgements">
<h3>Acknowledgements:</h3>
<ul class="simple">
<li>Frederic Raynal for proofreading this blogpost and all his feedback during my internship.</li>
<li>Joffrey Guilbon, Alexandre Adamski and Julien Chapouthier for the internship and their help, advice along with constant and rigourous feedback of my work.</li>
<li>Ivan Arce for his advice on backdoor creation and proofreading this blogpost.</li>
<li>Francisco Falcon and Nahuel Riva for their knowledge sharing, and beers sharing.</li>
<li>Thierry Dore for all his heap exploitation tricks and his previous knowledge on these chips.</li>
<li>Robin David for sharing with me his experimental tool and his knowledge.</li>
<li>Cedric Tessier for his great explanation about binary instrumentation and fuzzing.</li>
<li>Guillaume Heilles and Charles Hubain for the hardware training.</li>
</ul>
<p>Even if I haven't been in contact with them, their previous work on these chipsets where a crucial help for a beginner like me:</p>
<ul class="simple">
<li>Matthias Schulz from SEEMO lab</li>
<li>Gal Beniamini from Google Project Zero</li>
</ul>
</div>
<div class="section" id="references">
<h3>References</h3>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://ant.comm.ccu.edu.tw/course/92_WLAN/1_Papers/IEEE%20Std%20802.11-1997.pdf">http://ant.comm.ccu.edu.tw/course/92_WLAN/1_Papers/IEEE%20Std%20802.11-1997.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>IEEE Std 802.11a-1999 (Supplement to IEEE Std 802.11-1999), Part 11: Wireless LAN Medium Access Control (Mac) and Physical Layer (PHY) Specifications: High-speed Physical Layer in the 5 GHZ Band, <em>LAN/MAN Standards Committee, IEEE Computer Society</em>, approved 16 September 1999.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference external" href="https://github.com/seemoo-lab/nexmon">https://github.com/seemoo-lab/nexmon</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td><a class="reference external" href="https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/include/hndsoc.h">https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/include/hndsoc.h</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id13">2</a>, <a class="fn-backref" href="#id15">3</a>)</em> <a class="reference external" href="https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_4.html">https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_4.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id29" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[6]</a></td><td><a class="reference external" href="http://tuprints.ulb.tu-darmstadt.de/7243/">http://tuprints.ulb.tu-darmstadt.de/7243/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id30" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="https://github.com/cea-sec/Sibyl">https://github.com/cea-sec/Sibyl</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[8]</a></td><td><a class="reference external" href="https://lief.quarkslab.com">https://lief.quarkslab.com</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[9]</a></td><td><a class="reference external" href="https://googleprojectzero.blogspot.com/2017/09/over-air-vol-2-pt-1-exploiting-wi-fi.html">https://googleprojectzero.blogspot.com/2017/09/over-air-vol-2-pt-1-exploiting-wi-fi.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id33" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[10]</a></td><td><a class="reference external" href="https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-2-exploiting-wi-fi.html">https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-2-exploiting-wi-fi.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id34" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[11]</a></td><td><a class="reference external" href="https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-3-exploiting-wi-fi.html">https://googleprojectzero.blogspot.com/2017/10/over-air-vol-2-pt-3-exploiting-wi-fi.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[12]</td><td><em>(<a class="fn-backref" href="#id12">1</a>, <a class="fn-backref" href="#id19">2</a>)</em> <a class="reference external" href="https://blog.exodusintel.com/2017/07/26/broadpwn/">https://blog.exodusintel.com/2017/07/26/broadpwn/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[13]</a></td><td><a class="reference external" href="https://comsecuris.com/blog/posts/luaqemu_bcm_wifi/">https://comsecuris.com/blog/posts/luaqemu_bcm_wifi/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[14]</a></td><td><a class="reference external" href="https://github.com/Comsecuris/luaqemu">https://github.com/Comsecuris/luaqemu</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[15]</a></td><td><a class="reference external" href="https://mentor.ieee.org/802.11/dcn/04/11-04-0588-01-000i-tutorial-using-ouis-to-identify-cipher-and-akm-suites.doc">https://mentor.ieee.org/802.11/dcn/04/11-04-0588-01-000i-tutorial-using-ouis-to-identify-cipher-and-akm-suites.doc</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[16]</a></td><td><a class="reference external" href="https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_11.html">https://googleprojectzero.blogspot.com/2017/04/over-air-exploiting-broadcoms-wi-fi_11.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id40" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[17]</a></td><td><a class="reference external" href="https://github.com/torvalds/linux/commit/4835f37e3bafc138f8bfa3cbed2920dd56fed283#diff-66ea469ce534d8c3ba7147099b87fe78">https://github.com/torvalds/linux/commit/4835f37e3bafc138f8bfa3cbed2920dd56fed283#diff-66ea469ce534d8c3ba7147099b87fe78</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id41" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[18]</a></td><td><a class="reference external" href="https://www.aircrack-ng.org/">https://www.aircrack-ng.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id42" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[19]</a></td><td><a class="reference external" href="https://scapy.net/">https://scapy.net/</a></td></tr>
</tbody>
</table>
</div>
</div>

</div><!-- /.entry-content -->
<div class="comments">
  <h2>Comments</h2>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_identifier = "reverse-engineering-broadcom-wireless-chipsets.html";
    (function() {
     var dsq = document.createElement('script');
     dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'https://Quarkslab.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] ||
      document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
                </div>
                </article>
                </section>
        </div><!--/span-->

      </div><!--/row-->

      <hr>

      <footer>
      <address id="about">
        Powered by <a href="http://docs.getpelican.com">Pelican <i class="icon-external-link"></i></a>, Theme is from <a href="http://twitter.github.com/bootstrap/">Bootstrap from Twitter <i class="icon-external-link"></i></a>
      </address><!-- /#about -->
      </footer>

    </div><!--/.fluid-container-->


<script type="text/javascript">
    var disqus_shortname = 'Quarkslab';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>

    <!-- Le javascript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="./theme/js/jquery-1.7.2.min.js"></script>
    <script src="./theme/js/bootstrap.min.js"></script>
  </body>
</html>