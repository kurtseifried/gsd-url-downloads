<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Exception(al) Failure - Breaking the STM32F1 Read-Out Protection | blog.zapb.de</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../rss.xml">
<link rel="canonical" href="https://blog.zapb.de/stm32f1-exceptional-failure/">
<!--[if lt IE 9]><script src="../assets/js/html5.js"></script><![endif]--><meta name="author" content="Marc Schink &amp; Johannes Obermaier">
<link rel="prev" href="../stm32f1-announcement/" title="Coming soon: Breaking the STM32F1 Read-Out Protection" type="text/html">
<link rel="next" href="../one-exploit-to-rule-them-all/" title="One Exploit to Rule them All? On the Security of Drop-in Replacement and Counterfeit Microcontrollers" type="text/html">
<meta property="og:site_name" content="blog.zapb.de">
<meta property="og:title" content="Exception(al) Failure - Breaking the STM32F1 Read-Out Protection">
<meta property="og:url" content="https://blog.zapb.de/stm32f1-exceptional-failure/">
<meta property="og:description" content="The firmware of microcontrollers usually contains valuable data such as intellectual property and, in some cases, even cryptographic material.
In order to protect the confidentiality of these assets, ">
<meta property="og:image" content="https://blog.zapb.de/images/stm32f1-exceptional-failure/preview.jpg">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-03-17T08:00:00+01:00">
<meta property="article:tag" content="firmware">
<meta property="article:tag" content="hacking">
<meta property="article:tag" content="microcontroller">
<meta property="article:tag" content="security">
<meta property="article:tag" content="stm32">
<meta name="twitter:card" content="summary">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="https://blog.zapb.de/">

            <span id="blog-title">blog.zapb.de</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Exception(al) Failure - Breaking the STM32F1 Read-Out Protection</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Marc Schink &amp; Johannes Obermaier
            </span></p>
            <p class="dateline">
            <time class="published dt-published" datetime="2020-03-17T08:00:00+01:00" itemprop="datePublished" title="Tuesday, 17 March 2020">Tuesday, 17 March 2020</time></p>
            

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>The firmware of microcontrollers usually contains valuable data such as intellectual property and, in some cases, even cryptographic material.
In order to protect the confidentiality of these assets, most microcontrollers feature some kind of firmware read-out protection.
This security feature shall prevent adversaries with physical access to a device from reading out the internal flash memory.
Nevertheless, security researchers as well as hobbyists showed repeatedly that these security features can be circumvented.
In this research article, we examine the flash read-out protection (RDP) of the <a class="reference external" href="https://www.st.com/en/microcontrollers-microprocessors/stm32f1-series.html">STM32F1 series</a> from STMicroelectronics.
We discuss a novelly discovered vulnerability whose exploitation would be the first non-invasive way to circumvent the feature.
The issue results from an insufficient access restriction: flash data reads via the debug interface are blocked but the CPU's exception handling process is still able to read from flash memory via the ICode bus.
We explain in detail why and how this vulnerability exposes major parts of the internal memory, thereby affecting device security.</p>
<video style="width: 100%;" preload="none" poster="/images/stm32f1-exceptional-failure/firmware_extraction_576p_poster.jpg" title="Exception(al) Failure - Breaking the STM32F1 Read-Out Protection" controls><source src="../files/stm32f1-exceptional-failure/firmware_extraction_1080p.webm" type="video/webm"></source><source src="../files/stm32f1-exceptional-failure/firmware_extraction_1080p.mp4" type="video/mp4"></source></video><!-- TEASER_END --><div class="section" id="introduction">
<h2>Introduction</h2>
<p>For the protection of intellectual property and other sensitive data such as cryptographic material, securing the internal flash memory of a microcontroller is of utmost importance.
If an attacker gains access to the firmware, they can clone the product, alter its functionality or extract security credentials.
Thus, the hardening of microcontroller plays a major role in today's embedded system security — not only for high-security devices but also for commercial microcontrollers.</p>
<p>The deactivation of the debug interface is one usual way to prevent adversaries from gaining access to the flash memory, however, the implementation differs between microcontrollers.
For example, the debug interface of the <a class="reference external" href="https://www.st.com/en/microcontrollers-microprocessors/stm32f0-series.html">STM32F0 series</a> can be entirely switched off.
In contrast, the STM32F1 series does not directly support this, but relies on another approach.
One of its main security features is the flash memory read-out protection (RDP).
This security feature blocks all data accesses to the flash memory via the debug interface once a debug probe is attached to the microcontroller.
This means that an attacker is able to attach a debug probe to the microcontroller but cannot read out the flash memory content.</p>
<p>However, research has shown for some microcontrollers that this protection mechanism is flawed.
For the STM32F0 series, for instance, Johannes Obermaier and Stefan Tatschner presented an attack in <a class="reference external" href="https://www.usenix.org/system/files/conference/woot17/woot17-paper-obermaier.pdf">Shedding too much Light on a Microcontroller's Firmware Protection</a> that is able to extract protected data from flash memory.
Some researchers assumed that this vulnerability might also affect other series such as the STM32F1.
However, one of the authors <a class="reference external" href="https://www.mikrocontroller.net/topic/442881#5274755">contradicted</a> that the STM32F1 microcontroller family exhibits the same vulnerability in the debug interface.
Until now, the flash read-out protection mechanism of the STM32F1 series was considered as being secure and there was no evidence that it can be circumvented.
In this article, we discuss a vulnerability (<a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8004">CVE-2020-8004</a>) that leads to the first non-invasive attack against the flash protection mechanism of the STM32F1 family.</p>
</div>
<div class="section" id="discovering-the-vulnerability">
<h2>Discovering the Vulnerability</h2>
<p>The STM32F1 series does not provide a feature to permanently disable the debug interface.
For that reason, an attacker with physical access to the debug interface is always able to gain debug access to the microcontroller.
However, the integrated flash read-out protection prevents any data access to the flash memory once a debug probe is attached to the microcontroller.</p>
<p>In order to examine the flash read-out protection feature, we use an <a class="reference external" href="https://www.st.com/en/evaluation-tools/nucleo-f103rb.html">STM32 Nucleo-64 development board</a> with an STM32F103RB microcontroller.
The read-out protection of the microcontroller is enabled which means that the flash memory is not accessible via the debug interface.
The microcontroller is attached via the SWD debug interface to an external SEGGER J-Link debug probe, as depicted in <a class="reference internal" href="#figure-1">Figure 1</a>.</p>
<div class="figure align-center" id="figure-1">
<img alt="/images/stm32f1-exceptional-failure/setup.jpg" src="../images/stm32f1-exceptional-failure/setup.jpg" style="width: 768px;"><p class="caption">Figure 1: STM32 Nucleo-64 development board with attached SEGGER J-Link debug probe.</p>
</div>
<p>We begin our examination by establishing a debug connection to the target microcontroller.
For that, we start <a class="reference external" href="http://openocd.org/">OpenOCD</a> with the following command:</p>
<pre class="code bash"><a name="rest_code_1d6f7a0520804668b99fcf0680f95ac0-1"></a>openocd -f interface/jlink.cfg -c <span class="s2">"transport select swd"</span> -f target/stm32f1x.cfg
</pre>
<p>After that, we open a Telnet session on OpenOCD such that we can control the microcontroller.
Finally, we perform a device reset with the <code>reset halt</code> command and get the following output in our Telnet session:</p>
<pre class="code text"><a name="rest_code_86cd3abe6a99486faabb92cecbf0c845-1"></a>target halted due to debug-request, current mode: Thread
<a name="rest_code_86cd3abe6a99486faabb92cecbf0c845-2"></a>xPSR: 0x01000000 pc: 0x08000268 msp: 0x20005000
</pre>
<p>At a first glance, there is nothing special with this output.
However, when you take a closer look at the second line, especially one value should pop into your eyes: the program counter (PC) value <code class="docutils literal">0x08000268</code> is a valid address located in flash memory.
This is of major importance because a <em>reset</em> is a special kind of exception.
Every time an exception is generated, the processor loads the corresponding <em>exception entry address</em> from the vector table into the PC.
This procedure is sometimes referred to as <em>vector fetch</em>.
After a device reset, the vector table is located in flash memory.
Hence, this observation implies that the processor fetches the reset vector from flash memory even though the read-out protection is enabled.</p>
<p>But why is the exception entry process able to read the reset vector from flash memory?
The <a class="reference external" href="https://www.st.com/resource/en/reference_manual/cd00171190.pdf">STM32F1 reference manual</a> provides a hint:</p>
<blockquote class="pull-quote">
<p>The Cortex®-M3 CPU always fetches the reset vector on the ICode bus, which implies to have the boot space available only in the code area (typically, Flash memory).</p>
</blockquote>
<p>The reset vector is fetched via the ICode bus and thus handled like instruction fetches which are allowed despite the activated read-out protection.
The read-out protection seems to take care of data accesses via the data bus (DCode bus) only and hence the reset vector can still be fetched over the ICode bus.
The <a class="reference external" href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/DDI0337E_cortex_m3_r1p1_trm.pdf">Cortex-M3 Technical Reference Manual</a> provides additional information regarding vector fetches in general:</p>
<blockquote class="pull-quote">
<p>The vector fetch is performed over either the System bus or the ICode bus depending on where the vector table is located [...]</p>
</blockquote>
<p>In summary, the flash read-out protection of the STM32F1 does not block memory accesses via the ICode bus.
Once an exception takes place, the corresponding entry address stored in flash memory is fetched through the ICode bus and thereby exposes the memory content through the PC.</p>
</div>
<div class="section" id="exploitation">
<h2>Exploitation</h2>
<p>Our observation shows that once an exception takes place, the vector fetch exposes protected flash memory content through the PC.
In this section, we discuss how this behaviour can be exploited to bypass the read-out protection of the STM32F1.</p>
<p>We already mentioned the vector table: it contains the initialization value of the main stack pointer (MSP) followed by an entry address for every exception.
The vector table for microcontrollers based on the ARMv7-M architecture is shown in <a class="reference internal" href="#table-1">Table 1</a>.
The table lists the exceptions with their memory offset relative to the beginning of the vector table.
The first 16 exceptions of the vector table are mandatory and specified by the ARMv7-M architecture.
All other exceptions are so called <em>external interrupts</em>, they are optional and device specific.</p>
<table class="colwidths-given align-center" id="table-1">
<caption>Table 1: Vector table for microcontrollers implementing the ARMv7-M architecture.</caption>
<colgroup>
<col style="width: 30%">
<col style="width: 40%">
<col style="width: 30%">
</colgroup>
<thead><tr>
<th class="head"><p>Exception number</p></th>
<th class="head"><p>Exception</p></th>
<th class="head"><p>Offset</p></th>
</tr></thead>
<tbody>
<tr>
<td><p>-</p></td>
<td><p><em>Main stack pointer (MSP) initialization value</em></p></td>
<td><p>0x0</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>Reset</p></td>
<td><p>0x4</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>NMI</p></td>
<td><p>0x8</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>HardFault</p></td>
<td><p>0xc</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>MemManage</p></td>
<td><p>0x10</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>BusFault</p></td>
<td><p>0x14</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>UsageFault</p></td>
<td><p>0x18</p></td>
</tr>
<tr>
<td><p>7-10</p></td>
<td><p>Reserved</p></td>
<td><p>0x1c</p></td>
</tr>
<tr>
<td><p>11</p></td>
<td><p>SVCall</p></td>
<td><p>0x20</p></td>
</tr>
<tr>
<td><p>12</p></td>
<td><p>DebugMonitor</p></td>
<td><p>0x24</p></td>
</tr>
<tr>
<td><p>13</p></td>
<td><p>Reserved</p></td>
<td><p>0x28</p></td>
</tr>
<tr>
<td><p>14</p></td>
<td><p>PendSV</p></td>
<td><p>0x2c</p></td>
</tr>
<tr>
<td><p>15</p></td>
<td><p>SysTick</p></td>
<td><p>0x30</p></td>
</tr>
<tr>
<td><p>16</p></td>
<td><p>External Interrupt 0</p></td>
<td><p>0x34</p></td>
</tr>
<tr>
<td><p>...</p></td>
<td><p>...</p></td>
<td><p>...</p></td>
</tr>
</tbody>
</table>
<p>The basic exploitation idea is to deliberately generate exceptions such that the corresponding vector table entry is fetched from flash memory and exposed through the PC.
However, <a class="reference internal" href="#table-1">Table 1</a> shows that some entries are reserved and are not mapped to an exception, namely the entries 7 to 10 and 13.
Also needless to say, the initialization value for the MSP is not mapped to an exception.
For that reason, the corresponding table entries cannot be extracted via this approach.
We ignore this for the moment and address these limitations in more detail later in this article.</p>
<div class="section" id="vector-table-offset">
<h3>Vector Table Offset</h3>
<p>At this point, the following question may arise: <em>why should I care about the confidentiality of the vector table content?</em></p>
<p>Indeed, the content of the vector table is usually not confidential as it only contains the exception entry addresses.
But note that the ARMv7-M architecture specifies a Vector Table Offset Register (VTOR) that determines the location of the vector table inside the address space.
This feature is usually used to relocate the vector table when there are multiple applications on the microcontroller, for example, a bootloader and a main application.
With that, both applications can have their own vector table and exception handlers.
The crucial point here is again, that we have debug access to the entire device except for the flash memory.
With help of the VTOR, we are able to relocate the vector table within the flash memory region and extract large amount of its data.</p>
<p>In order to use the vector table relocation, we split the flash memory into equally sized blocks of 32 words, as depicted in <a class="reference internal" href="#figure-2">Figure 2</a>.
The block size is related to the vector table size and, as required by the ARMv7-M specification, must be a power of 2.
For example, the STM32F103 has 59 exceptions and therefore the <em>actual</em> vector table size is 64.
However, this means that we do not have enough exceptions to access all its table entries.
For that reason, we use the largest possible vector table that fits in 59 which is 32.</p>
<div class="figure align-center" id="figure-2">
<img alt="/images/stm32f1-exceptional-failure/memory_vector_table.svg" src="../images/stm32f1-exceptional-failure/memory_vector_table.svg" style="width: 480px;"><p class="caption">Figure 2: Relocation of the vector table within the flash memory. Inaccessible table entries are highlighted.</p>
</div>
<p>The seven highlighted memory words in <a class="reference internal" href="#figure-2">Figure 2</a> cannot be extracted.
The first two words are the initialization value for the MSP and the reset vector.
The other words correspond to the reserved entries of the vector table.
The MSP initialization value and the reset vector are special and can only be extracted when the vector table is located at the beginning the of the flash memory, its default location.
The reason is that a device reset is necessary to extract these value, however, this also resets the VTOR and relocates the vector table to the beginning of the flash memory region.</p>
<p>These limitations can be reduced by using exceptions that exceed the vector table size.
In this case, exceptions with a number greater than 31.
According to section 4.4.4 of the <a class="reference external" href="https://www.st.com/resource/en/programming_manual/cd00228163.pdf">STM32F1 programming manual</a>, the vector table location must be aligned to the <em>actual</em> vector table size, 64 in case of the STM32F103.
But what happens when our vector table is unaligned and we generate exceptions with numbers greater than the vector table size?
It turns out that these exceptions are mapped to the beginning of the vector table.
<a class="reference internal" href="#figure-3">Figure 3</a> illustrates this <em>wrap-around behaviour</em> for an unaligned vector table with 32 entries.
On the left-hand side, the regular vector table with its inaccessible entries highlighted is depicted.
On the right-hand side, the figure shows how the wrap-around behaviour makes the inaccessible parts of the vector table accessible.
The highlighted vector table entries are now accessible by exceptions that exceed the vector table size.</p>
<div class="figure align-center" id="figure-3">
<img alt="/images/stm32f1-exceptional-failure/memory_vector_table_wrap_around.svg" src="../images/stm32f1-exceptional-failure/memory_vector_table_wrap_around.svg" style="width: 480px;"><p class="caption">Figure 3: Wrap-around behaviour of an unaligned vector table. Inaccessible entries (red) become accessible (blue) when an exception exceeds the table size.</p>
</div>
<p>Note that in <a class="reference internal" href="#figure-3">Figure 3</a>, the focus is on the inaccessible parts of the vector table.
The other entries can also be extracted via the wrap-around behaviour, however, this is not necessary since they can be extracted regularly.
With the help of the wrap-around, we are now able to extract vector table entries that were reserved or inaccessible before.
Even the first two entries which were only extractable when the vector table is located at the beginning of the flash memory region.
The only limitation that remains is that we can use this approach only for unaligned vector tables.
Nevertheless, we reduced the number of inaccessible memory words by a factor of two.
Note that this approach is <em>one</em> way to make use of the additional external interrupts.
We use this way because it is very convenient to implement.</p>
<p>Now, we have almost everything we need to extract nearly arbitrary parts of the flash memory.
In the next section, we describe the last missing piece: how to generate exceptions on purpose.</p>
</div>
<div class="section" id="exception-generation">
<h3>Exception Generation</h3>
<p>To generate each individual exception for firmware extraction, we continue as follows.
We need three steps to trigger an exception:</p>
<blockquote>
<ol class="arabic simple">
<li><p>Perform a device reset such that the microcontroller is in a defined state and to recover it from possible faults and lockups.</p></li>
<li><p>Configure the microcontroller such that the indented exception is pending.</p></li>
<li><p>Perform a single step to make the pending exception active.</p></li>
</ol>
</blockquote>
<p>The Non-Maskable Interrupt (NMI), PendSV and SysTick exception can easily
made pending by setting the corresponding bits <code class="docutils literal">NMIPENDSET</code>, <code class="docutils literal">PENDSVSET</code> and
<code class="docutils literal">PENDSTSET</code> respectively.
These bits can be found in the Interrupt Control and State Register (ICSR).
The same holds for the DebugMonitor exception which can be made pending by setting
the <code class="docutils literal">MON_PEND</code> bit in the Debug Exception and Monitor Control Register (DEMCR).</p>
<p>For example, the following OpenOCD commands makes the PendSV exception pending:</p>
<pre class="code text"><a name="rest_code_7acb104ce6e345b5b1582c984437df25-1"></a>mww 0xe000ed04 0x10000000
</pre>
<p>Since the processor is in debug mode and halted, we need to give it the
chance to execute the exception.
For that, we use the <code>step</code> command to execute only a single instruction.
In order to avoid side-effects by the executed instruction, we execute a single <code>nop</code> instruction placed in SRAM at address <code>0x20000000</code>.</p>
<pre class="code text"><a name="rest_code_c5d7bfd815dc497f8754221d8420dae5-1"></a>mwh 0x20000000 0xbf00
<a name="rest_code_c5d7bfd815dc497f8754221d8420dae5-2"></a>reg pc 0x20000000
</pre>
<p>Note that it is necessary to disable <em>interrupt masking</em>.
This feature is enabled by default and can be deactivated with the following <a class="reference external" href="http://openocd.org/doc/html/Architecture-and-Core-Commands.html#index-cortex_005fm-maskisr">command</a>:</p>
<pre class="code text"><a name="rest_code_e7992f33a06d452191c628296259518c-1"></a>cortex_m maskisr off
</pre>
<p>This command changes the single-stepping behaviour and controls the <code class="docutils literal">C_MASKINTS</code>
bit in the Debug Halting Control and Status Register (DHCSR).
This bit determines whether PendSV, SysTick and all external interrupts shall be
masked.
By default, <code class="docutils literal">maskisr</code> is set to <em>auto</em> which means that a <code class="docutils literal">step</code> command first allows pending interrupt handlers to execute and then steps over the desired instruction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code>maskisr</code> command is not available for so called high-level adapters (HLA) in OpenOCD.
For that reason, we do not use the integrated ST-LINK debug probe of the Nucleo-64 development board.</p>
</div>
<p>Once an exception is generated, you may experience that there is a mismatch between the exception entry address in the vector table and the PC value.
The least-significant bit (LSB) may be incorrect.
The reason is that the LSB of the exception entry address is not loaded into the PC but used as Thumb state of the processor.
Since the Thumb state is encoded in the Execution Program State Register (EPSR), we are able to recover the entire exception entry address by combining the PC and the Thumb state bit.</p>
<p>We have all building blocks required to extract vector table entries.
In the following, we elaborate how to generate the remaining exceptions.
For simplicity, we omit the first and last step of the exception generation process throughout the remainder of this article.</p>
<div class="section" id="busfault">
<h4>BusFault</h4>
<p>A BusFault exception occurs, for example, when a memory instruction accesses
an invalid memory region.
Hence, we can generate a BusFault by executing a load instruction that performs
a read access on an invalid memory region.</p>
<p>For that, we place an <code>ldr r0, [r1, #0]</code> into the SRAM at address <code class="docutils literal">0x20000000</code> and configure the base register <code>r1</code> and the PC accordingly:</p>
<pre class="code text"><a name="rest_code_b371517ce71a4aa38e149cb356ea479d-1"></a>mwh 0x20000000 0x0868
<a name="rest_code_b371517ce71a4aa38e149cb356ea479d-2"></a>reg r1 0xf0000000
<a name="rest_code_b371517ce71a4aa38e149cb356ea479d-3"></a>reg pc 0x20000000
</pre>
<p>The address <code>0xf0000000</code> stored in <code>r1</code> is part of the vendor-specific memory region.
In case of the STM32F1, this address is not mapped in the memory space.
Therefore, every memory operation on this address is illegal and thus suitable to generate a BusFault exception.
All other addresses that are not mapped work as well.</p>
<p>Before we are able to generate a BusFault exception, we need to enable it by
setting the <code class="docutils literal">BUSFAULTENA</code> bit in the System Handler Control and State Register (SHCSR):</p>
<pre class="code text"><a name="rest_code_f98f3b8d5e9648e2af5650d66237e476-1"></a>mww 0xe000ed24 0x20000
</pre>
<p>This step is necessary because otherwise <em>priority escalation</em> would take place and the processor would generate a HardFault exception instead of a BusFault.</p>
</div>
<div class="section" id="memmanage">
<h4>MemManage</h4>
<p>The MemManage exception is generated whenever a memory protection fault occurs.
Among others, this happens when the processor attempts to execute code in a memory region that is marked as eXecute Never (XN).</p>
<p>In order to cause a memory protection violation, we configure the processor such that it attempts to execute code on a memory region marked as XN.
In our case, we chose the first address of the system memory address space which is at the address <code class="docutils literal">0xe0000000</code>.</p>
<pre class="code text"><a name="rest_code_4663f26b7c6c45a79c2a16c61a920baa-1"></a>reg pc 0xe0000000
</pre>
<p>As for the BusFault exception, the MemManage exception needs to be enabled.
We do this by setting the <code class="docutils literal">MEMFAULTENA</code> bit in the SHCSR:</p>
<pre class="code text"><a name="rest_code_d0326e6f2f01406cb3c1aecb0bc5f84e-1"></a>mww 0xe000ed24 0x10000
</pre>
</div>
<div class="section" id="usagefault">
<h4>UsageFault</h4>
<p>UsageFault exceptions can occur for a variety of reasons.
One reason is, for example, when an unaligned memory load or store operation is performed.</p>
<p>However, the straightforward way is to execute an undefined instruction such as <code class="docutils literal">0xffff</code>.
We place this instruction in SRAM at address <code>0x20000000</code> and configure the PC accordingly:</p>
<pre class="code text"><a name="rest_code_6bc9ee442ece46c68b042fa1469eac7d-1"></a>mwh 0x20000000 0xffff
<a name="rest_code_6bc9ee442ece46c68b042fa1469eac7d-2"></a>reg pc 0x20000000
</pre>
<p>As for the other exceptions, the UsageFault exception needs to be enabled.
This can be done by setting the <code class="docutils literal">USGFAULTENA</code> bit in the SHCSR:</p>
<pre class="code text"><a name="rest_code_fb1923f76e7a4aecae8fc781002f86a8-1"></a>mww 0xe000ed24 0x40000
</pre>
</div>
<div class="section" id="hardfault">
<h4>HardFault</h4>
<p>A HardFault is a generic fault that is generated whenever a fault cannot be handled by any other exception.</p>
<p>There are different means to generate a HardFault exception manually.
A straightforward way is to generate one of the previously mentioned exceptions without enabling it.
As explained before, this causes a <em>priority escalation</em> and the HardFault exception gets generated.</p>
</div>
<div class="section" id="svcall">
<h4>SVCall</h4>
<p>A Supervisor Call (SVCall) is used by software to call the operating system.
This exception is generated whenever the processor executes an <code>svc</code> instruction.</p>
<p>We generate this exception by placing an <code>svc #0</code> instruction in SRAM and execute it with a single step.</p>
<pre class="code text"><a name="rest_code_a4255203885b42fd827ebb90dde4d208-1"></a>mwh 0x20000000 0xdf00
<a name="rest_code_a4255203885b42fd827ebb90dde4d208-2"></a>reg pc 0x20000000
</pre>
<p>Since we are only interested in generating an SVCall exception, the immediate value <code>#imm</code> is not important and can be arbitrarily chosen.
In contrast to the former two exceptions, a supervisor call is permanently
enabled.</p>
</div>
<div class="section" id="external-interrupts">
<h4>External Interrupts</h4>
<p>The Nested Vectored Interrupt Controller (NVIC) handles all the external
interrupts.
It provides two set of registers: one to enable external interrupts and a second one to make them pending.
In order to trigger an external interrupt, we set the corresponding bits in both registers to enable the interrupt and make it pending.
Every bit corresponds to an external interrupt.</p>
<p>For example, in case of the STM32F1 series, the first external interrupt is the window watchdog (WWDG) interrupt.
In order to trigger this interrupt, we set the first bit in both registers:</p>
<pre class="code text"><a name="rest_code_d133b6f4e93d4d6ebdf29374b4b3876a-1"></a>mww 0xe000e100 0x1
<a name="rest_code_d133b6f4e93d4d6ebdf29374b4b3876a-2"></a>mww 0xe000e200 0x1
</pre>
<p>All other external interrupts can be generated accordingly.</p>
<p>The number of external interrupts varies a lot among the different devices of the STM32F1 family.
Additionally, the documentation is sometimes not accurate.
For example, according to the STM32F1 reference manual, the external interrupts 43 to 49 of <em>connectivity line</em> devices are reserved.
However, we found out that they can be generated like all the other interrupts.
The importance of the available external interrupts will be seen in the next section.</p>
</div>
</div>
</div>
<div class="section" id="performance">
<h2>Performance</h2>
<p>The amount of extractable memory content and the extraction speed are key
indicators whether the identified vulnerability undermines the security of the read-out protection in field applications.</p>
<p>In order to asses the severity of this vulnerability, we implemented a
Python script that generates exceptions in an automated fashion to extract firmware from a read-out protected microcontroller.
We evaluated the presented attack on three different devices of the STM32F1 series.
In all cases, we aimed to extract 128 KiB of flash memory from the devices.
The evaluation results are listed in <a class="reference internal" href="#table-2">Table 2</a>.</p>
<table class="align-center" id="table-2">
<caption>Table 2: Extraction time and coverage for three devices of the STM32F1 series.</caption>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead><tr>
<th class="head"><p>Device</p></th>
<th class="head"><p>External interrupts</p></th>
<th class="head"><p>Extraction time</p></th>
<th class="head"><p>Extraction coverage</p></th>
</tr></thead>
<tbody>
<tr>
<td><p>STM32F100</p></td>
<td><p>55</p></td>
<td><p>48.8 min</p></td>
<td><p>91.4 %</p></td>
</tr>
<tr>
<td><p>STM32F103</p></td>
<td><p>43</p></td>
<td><p>48.2 min</p></td>
<td><p>89.1 %</p></td>
</tr>
<tr>
<td><p>STM32F107</p></td>
<td><p>68</p></td>
<td><p>51.0 min</p></td>
<td><p>94.5 %</p></td>
</tr>
</tbody>
</table>
<p>The results show that the amount of flash memory that can be extracted correlates with number of external interrupts.
The most data can be extracted from the STM32107 microcontroller with its 68 external interrupts.
The table also shows that the extraction time slightly increases with the increasing amount of extracted data.</p>
<p>We used a SEGGER J-Link debug probe with an adapter speed of 3500 kHz for the performance evaluation.
Note that the adapter speed of your debug probe is an important factor for the extraction time and might also be influenced by further factors in your setup, for example, your computer system.</p>
<p>In a nutshell, these results show that the attack is indeed practically feasible as it can be executed in reasonable time: in less than one hour.</p>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>In this article, we discussed a vulnerability in the flash read-out protection mechanism of the STM32F1 microcontroller series.
We showed that the exploitation is non-invasive and requires only access to the microcontroller's debug interface.
Hence, this attack is clearly within the typical attacker models of flash readout protection mechanisms.</p>
<p>The presented attack has certain limitations and does not allow an attacker to read out the entire flash memory.
However, depending on the device, an attacker is able to read out up to 94.5 percent of the flash memory content in less than an hour.
For that reason, we consider this read-out protection mechanism as broken and we do not recommand to rely on this feature anymore.
Since the STM32F1 series has no other firmware protection mechanism, the only way known to the authors to avoid exploitation and thus keep the entire flash memory content confidential is to <em>physically</em> prevent an attacker from gaining access to the debug interface.</p>
</div>
<div class="section" id="availability">
<h2>Availability</h2>
<p>In order to encourage discussions and make our research results comprehensible and replicable, we publish the source code that was developed during our research.
The source code is licensed  under the GPLv3+ and can be found on <a class="reference external" href="https://gitlab.zapb.de/zapb/stm32f1-firmware-extractor">https://gitlab.zapb.de/zapb/stm32f1-firmware-extractor</a>.</p>
</div>
<div class="section" id="coordinated-disclosure">
<h2>Coordinated Disclosure</h2>
<p>The publication of our findings was preceded by a coordinated vulnerability disclosure process.
We informed STMicroelectronics more than 100 days prior to the publication of this article.</p>
<blockquote>
<ul class="simple">
<li><p><strong>28 November 2019:</strong> Technical details about the vulnerability and the disclosure timeline provided to STMicroelectronics.</p></li>
<li><p><strong>08 December 2019:</strong> No response from STMicroelectronics so far. Reminder with technical details and disclosure timeline.</p></li>
<li><p><strong>23 December 2019:</strong> Still no response from STMicroelectronics. Reminder without technical details.</p></li>
<li><p><strong>06 January 2020:</strong> Reminder from <a class="reference external" href="https://www.cert-bund.de/">CERT Bund</a> and immediate response from STMicroelectronics.</p></li>
<li><p><strong>10 January 2020:</strong> Conference call with STMicroelectronics and CERT Bund as mediator.</p></li>
<li><p><strong>15 January to 07 February 2020:</strong> Further discussions between STMicroelectronics and CERT Bund.</p></li>
<li><p><strong>01 February 2020:</strong> Public announcement of the vulnerability without technical details.</p></li>
<li><p><strong>17 March 2020:</strong> Publication of this article and supplementary materials.</p></li>
</ul>
</blockquote>
</div>
<div class="section" id="about-the-authors">
<h2>About the Authors</h2>
<p><a class="reference external" href="mailto:mail(a)marcschink.de">Marc Schink</a> and <a class="reference external" href="mailto:mail(a)obermaier-johannes.de">Johannes Obermaier</a> are two embedded system security researchers with a background in computer science and electrical engineering.
They focus especially on microcontrollers that both encounter in their everyday live.
With their research and publications they aim at improving security by an open discussion about the strength of security features and wish for improvements.</p>
</div>
</div>
    </div>
    <aside class="postpromonav"><nav></nav></aside></article><!--End of body content--><footer id="footer">
            Except where otherwise noted, content on this site is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons BY-NC-SA 4.0</a> license.
            
            
        </footer>
</div>
</div>


        <script src="../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element) {
            return element.getElementsByTagName('img')[0].alt;
    }});
    </script>
</body>
</html>
